# 记忆科技综合计划项目
ramaxel-algorithm
git地址：http://192.168.31.204/hg-algorithm/ramaxel-algorithm.git
## 1. 项目背景

记忆科技综合计划项目旨在解决跨工厂的物料需求计划（MRP）、主生产计划（MPS）以及短期齐套模拟（STK）多种场景下的替代料合理分配问题。特别关注不对称替代的业务场景，即替代料不能完全互换使用的情形。

传统的逻辑分配方案在这些场景下无法实现最优分配，因此本项目采用优化算法，以提高替代料分配的全局效率和效果。

## 2. 应用场景

| **场景分类**          | **需求来源**    | **约束** | **目标**     | **应用**                     |
| --------------------- | --------------- | -------- | ------------ | ---------------------------- |
| **供应链网络计划SNP** | PIR             | 需求     | 最小净需求量 | 生成成品、半成品计划订单     |
| **主生产计划MPS**     | PIR             | 供给     | 最大齐套数量 | 中、长期计划齐套模拟         |
| **物料需求计划MRP**   | PIR             | 需求     | 最小净需求量 | 生成采购建议、跨工厂调拨建议 |
| **短期齐套STK**       | 真实/询交期订单 | 供给     | 最大齐套数量 | 短期需求齐套模拟             |
| **资金计划FRP**       | 年度计划        | 需求     | 最小净需求量 | 生成毛需求、净需求数量       |

### 2.1 SNP

供应链网络计划（Supply Network Planning, SNP）处理供应链网络中的需求传递，目的是最小化各供应节点（如工厂）的成品和半成品净生产需求。

考虑到存在成品、半成品不完全可替代的业务场景，SNP通过引入优化算法（如线性规划、整数规划或启发式方法），在满足需求的同时最小化净生产需求。

### 2.2 MPS

主生产计划（Master Production Schedule, MPS）主要针对中长期计划进行物料的齐套模拟。通过计划的物料向下展开到组件乃至原料层，并通过从下至上的反馈机制展示齐套结果。

图1详细描绘了MPS中齐套运算的流程。此过程中，通过优化算法调整原料分配，以确保材料供应的连续性并最大化产能利用率。

<table style="width: 100%; border: none; background-color: white">
    <tr style="border: none;">
        <td style="border: none; text-align: center;">
            <img src="https://gitee.com/uc4334/imgs/raw/master/img/202403091415221.png" style="zoom:40%;" />
            <div style="margin-top: 10px; font-size: 16px; color: #333;">图1 齐套运算过程</div>
        </td>
    </tr>
</table>
### 2.3 MRP

物料需求计划（Material Requirements Planning, MRP）是以需求数量为约束，通过算法优化不完全替代场景下的原料分配，追求最小化自制件生产、原料采购的净需求数量。

MRP运算中，识别物料的工厂“获取类型”属性，对于自制件（获取类型=E）的，需要根据需求日期（计划订单的计划开始日期）展开其下层物料BOM。对于外购件（获取类型=F）或解耦半成品（相关需求=1）不向下展开。                               

MRP运算采用占料分配方式，默认优先分配本工厂库存、在途；各工厂在满足本工厂需求后，仍有剩余的库存数量，可分配给其他工厂使用。当多个工厂均有可用库存时，通过调拨工厂优先级顺序，决定跨工厂调拨的分配方案，生成跨工厂调拨建议。

记忆科技的计划运行周期为周，跨工厂调拨时，默认锁定本工厂两周内的需求。即本工厂两周内全部需求满足后，剩余库存才允许调拨。

当存在成品、半成品替代时，还需要根据其下级的供给决定该需求的分配。该过程需要通过算法优化，最大程度消耗现有供给，并选择触发最小采购需求的生产方案。

MRP运算物料分配后，所产生的原料缺口数量，即为净需求数量，进而执行后处理，生成采购建议。

### 2.4 STK

短期齐套（Short-term Kitting, STK）模拟，主要针对真实客户订单（包括CIR、L2客户的SO、内部SO）以及询交期订单（Sizing）输出齐套结果，指导生成工单建议。

短期齐套模拟的特点，主要体现在较多的临时替代、BOM临时变更、以及客户专用、业务专用的分料规则上。

短期齐套的目标，是在替代料合理分配基本上，满足最大齐套数量。

短期齐套模拟中，齐套结果为“在手齐套”（“在手齐套“是指本工厂库存+Dummy Stock满足齐套需求）类型的，允许生成工单建议。

仅在特殊业务场景（XY业务跨工厂分料）下，使用跨工厂库存齐套也定义为”在手齐套“类型。

### 2.5 FRP

资金计划（Financial Resources Planning, FRP）运算需求与跨工厂MRP类似，只是需求来源不是主生产计划，而是用于做资金计划的年度预测计划。

资金计划结果主要输出原料的毛需求、净需求数量。

## 3. 执行流程

### 3.1 业务流程

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403271446882.png" style="zoom:40%;" />

### 3.2 算法流程

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202404151453951.png" style="zoom:50%;" />





<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403271729500.png" style="zoom:40%;" />

## 4. 数学模型

### 4.1 最大化齐套数量

#### 4.1.1 使用场景

- MPS
- 短期齐套

#### 4.1.2 假设条件

- 复杂BOM中，同一原材料号可能出现多次，同一半成品料号不会出现多次；
- 虚拟料没有原始库存量；
- 对于成品替代/半成品替代,以上层虚拟料作为成品料号;
- 需求可能为成品或上层虚拟料;
- 替代组中包含类型为：成品、半成品、虚拟料、原材料，不包含替代组；

#### 4.1.3 已知条件

需求数量：$DQ$

成品集合：$Product=\{PT_m|m=1,2,\cdots,M\}$

半成品供给量：$PTQ_i$

半成品集合：$Semi=\{S_i|i=1,2,\cdots,I\}$

半成品供给量：$SQ_i$

虚拟料集合：$Phantom=\{P_j|j=1,2,\cdots,J\}$

替代组集合：$Alternative=\{A_k|k=1,2,\cdots,K\}$

原材料集合：$Raw=\{R_r|r=1,2,\cdots,R\}$

原材料供给量：$RQ_r$

原材料出现次数：$c_r$

$a_{u,v}=\begin{cases}1,\quad v\in u,\\0,\quad otherwise\end{cases}\quad u\in \{0\}\cup I \cup J \cup K;\;v\in M \cup  I \cup J \cup K \cup L$  ：bom上下层关系，$u$为上层编号，$v$为下层编号，当$u=0$时表示需求对应的BOM层级(可能为成品或上层虚拟料)

$b_{u,v}$：bom上下层的比例， $u$为上层编号，$v$为下层编号，当$a_{u,v}=1$时$b_{u,v}$存在，当$a_{u,v}=0$时$b_{u,v}$不存在

#### 4.1.4 决策变量

对于多次出现的相同料号的原材料，分别建立不同的决策变量，原材料编号$l=1,2,\cdots,\sum_{r=1}^{R}c_r$

$KQ$：需求的齐套数量

$PTD_m$：成品$m$的计算用量（对应product_bom）

$SD_i$：半成品$i$的计算用量（对应semi_bom）

$PD_j$：虚拟料$j$的计算用量（对应phantom_bom）

$AD_k$：替代组$k$的计算用量（对应alternative_bom）

$RD_l$：原材料$l$的计算用量

#### 4.1.5 目标函数&约束条件

$$
\begin{align}
&\max KQ\\
s.t.&KQ=\min \left( \frac{SD_i*a_{0,i}+SQ_i}{b_{0,i}}, \frac{PD_j*a_{0,j}}{b_{0,j}},\frac{AD_k*a_{0,k}}{b_{0,k}},\frac{RD_l*a_{0,l}}{b_{0,l}}\right)\tag{1}\\
&PTD_m = \min \left( \frac{SD_i*a_{m,i}+SQ_i}{b_{m,i}}, \frac{PD_j*a_{m,j}}{b_{m,j}},\frac{AD_k*a_{m,k}}{b_{m,k}},\frac{RD_l*a_{m,l}}{b_{m,l}}\right)\tag{2}\\
&SD_i= \min \left( \frac{SD_i'*a_{i,i'} + SQ_i'}{b_{i,i'}}, \frac{PD_j*a_{i,j}}{b_{i,j}},\frac{AD_k*a_{i,k}}{b_{i,k}},\frac{RD_l*a_{i,l}}{b_{i,l}}\right)\tag{3}\\
&PD_j = \min \left( \frac{SD_i*a_{j,i}+SQ_i}{b_{j,i}}, \frac{PD_j'*a_{j,j'}}{b_{j,j'}},\frac{AD_k*a_{j,k}}{b_{j,k}},\frac{RD_l*a_{j,l}}{b_{j,l}}\right)\tag{4}\\
&AD_k=\sum_{m}\left(\frac{PTD_m*a_{m,k}+PTQ_m}{b_{m,k}}\right)+\sum_{i}\left(\frac{SD_i*a_{i,k}+SQ_i}{b_{i,k}}\right)+\sum_{j}\left(\frac{PD_j*a_{j,k}}{b_{j,k}}\right)+\sum_{l}\left(\frac{RD_l*a_{k,l}}{b_{k,l}}\right)\tag{5}\\
&\sum_{l\in f(l,c_r,R)}RD_l\leq R_r\tag{6}\\
&0\leq KQ \leq DQ,\;PTD_m\geq 0,\;SD_i\geq 0,\;PD_j\geq 0,\;AD_k\geq 0,\;RD_l\geq 0 \tag{7}\\
\end{align}
$$

约束（1）：需求齐套量计算，受下层半成品、虚拟料、替代组、原材料中的短板物料影响；

约束（2）：成品齐套量计算，受半成品、虚拟料、替代组、原材料中的短板物料影响；

约束（3）：半成品齐套量计算，受下层半成品、虚拟料、替代组、原材料中的短板物料影响；

约束（4）：虚拟料齐套量计算，受下层半成品、虚拟料、替代组、原材料中的短板物料影响；

约束（5）：替代组齐套量计算，等于下层成品、半成品、虚拟料、原材料的的齐套量总和；

约束（6）：原材料的使用量约束，不超过其供给量，其中$f(l,c_r,R)$为原材料编号$l$对应的原材料$R_r$出现次数的集合；

约束（7）：非负约束；



### 4.2 最小化净需求量

#### 4.2.1 使用场景

- SNP
- MRP
- 资金计划

#### 4.1.2 假设条件

- 复杂BOM中，同一原材料号可能出现多次，同一半成品料号不会出现多次；
- 虚拟料没有原始库存量；
- 对于成品替代/半成品替代,以上层虚拟料作为成品料号;
- 需求可能为成品或上层虚拟料;
- 替代组中包含类型为：成品、半成品、虚拟料、原材料，不包含替代组；

#### 4.1.3 已知条件

需求数量：$DQ$

成品集合：$Product=\{PT_m|m=1,2,\cdots,M\}$

半成品供给量：$PTQ_i$

半成品集合：$Semi=\{S_i|i=1,2,\cdots,I\}$

半成品供给量：$SQ_i$

虚拟料集合：$Phantom=\{P_j|j=1,2,\cdots,J\}$

替代组集合：$Alternative=\{A_k|k=1,2,\cdots,K\}$

原材料集合：$Raw=\{R_r|r=1,2,\cdots,R\}$

原材料供给量：$RQ_r$

原材料出现次数：$c_r$

$a_{u,v}=\begin{cases}1,\quad v\in u,\\0,\quad otherwise\end{cases}\quad u\in \{0\}\cup I \cup J \cup K;\;v\in M \cup  I \cup J \cup K \cup L$  ：bom上下层关系，$u$为上层编号，$v$为下层编号，当$u=0$时表示需求对应的BOM层级(可能为成品或上层虚拟料)

$b_{u,v}$：bom上下层的比例， $u$为上层编号，$v$为下层编号，当$a_{u,v}=1$时$b_{u,v}$存在，当$a_{u,v}=0$时$b_{u,v}$不存在

#### 4.1.4 决策变量

对于多次出现的相同料号的原材料，分别建立不同的决策变量，原材料编号$l=1,2,\cdots,\sum_{r=1}^{R}c_r$

$KQ$：需求的齐套数量

$PTD_m$：成品$m$的计算用量（对应product_bom）

$SD_i$：半成品$i$的计算用量（对应semi_bom）

$PD_j$：虚拟料$j$的计算用量（对应phantom_bom）

$AD_k$：替代组$k$的计算用量（对应alternative_bom）

$RD_l$：原材料$l$的计算用量

#### 4.1.5 目标函数&约束条件

$$
\begin{align}
&\min \sum_{R_r\in Raw}RS_r\\
s.t.& KQ \geq DQ \tag{1}\\
&KQ=\min \left( \frac{SD_i*a_{0,i}+SQ_i}{b_{0,i}}, \frac{PD_j*a_{0,j}}{b_{0,j}},\frac{AD_k*a_{0,k}}{b_{0,k}},\frac{RD_l*a_{0,l}}{b_{0,l}}\right)\tag{2}\\
&PTD_m = \min \left( \frac{SD_i*a_{m,i}+SQ_i}{b_{m,i}}, \frac{PD_j*a_{m,j}}{b_{m,j}},\frac{AD_k*a_{m,k}}{b_{m,k}},\frac{RD_l*a_{m,l}}{b_{m,l}}\right)\tag{3}\\
&SD_i= \min \left( \frac{SD_i'*a_{i,i'} + SQ_i'}{b_{i,i'}}, \frac{PD_j*a_{i,j}}{b_{i,j}},\frac{AD_k*a_{i,k}}{b_{i,k}},\frac{RD_l*a_{i,l}}{b_{i,l}}\right)\tag{4}\\
&PD_j = \min \left( \frac{SD_i*a_{j,i}+SQ_i}{b_{j,i}}, \frac{PD_j*a_{j,j'}}{b_{j,j'}},\frac{AD_k*a_{j,k}}{b_{j,k}},\frac{RD_l*a_{j,l}}{b_{j,l}}\right)\tag{5}\\
&AD_k=\sum_{m}\left(\frac{PTD_m*a_{m,k}+PTQ_m}{b_{m,k}}\right)+\sum_{i}\left(\frac{SD_i*a_{i,k}+SQ_i}{b_{i,k}}\right)+\sum_{j}\left(\frac{PD_j*a_{j,k}}{b_{j,k}}\right)+\sum_{l}\left(\frac{RD_l*a_{k,l}}{b_{k,l}}\right)\tag{6}\\
&\sum_{l\in f(l,c_r,R)}RD_l\leq R_r + RS_r\quad\forall\;r\tag{7}\\
&\;PTD_m\geq 0,\;SD_i\geq 0,\;PD_j\geq 0,\;AD_k\geq 0,\;RD_l\geq 0 \quad\forall\;i,j,k,l \tag{8}\\
&RS_r \geq 0 \quad\forall\;r\tag{9}
\end{align}
$$

约束（1）：需求齐套数量必须满足需求量的约束；

约束（2）：需求齐套量计算，受下层半成品、虚拟料、替代组、原材料中的短板物料影响；

约束（3）：成品齐套量计算，受下层半成品、虚拟料、替代组、原材料中的短板物料影响；

约束（4）：半成品齐套量计算，受下层半成品、虚拟料、替代组、原材料中的短板物料影响；

约束（5）：虚拟料齐套量计算，受下层半成品、虚拟料、替代组、原材料中的短板物料影响；

约束（6）：替代组齐套量计算，等于下层成品、半成品、虚拟料、原材料的的齐套量总和；

约束（7）：原材料的使用量约束，不超过其供给量+缺量，其中$f(l,c_r,R)$为原材料编号$l$对应的原材料$R_r$出现次数的集合；

约束（8）（9）：非负约束；



## 5. 输入输出数据格式

### 5.1 输入数据

#### 5.1.1 输入消息数据

```json
{
  "message_id": "20240221103710",				   // 消息ID,需保证唯一性("YYYYMMDDHHmmss"格式, 由Java传入)
  "message_create_time": 1667467811, 			 // 消息创建的时间戳(颗粒度到秒,下同)
  "message_calc_time": 1667467822,				 // 计算开始时间戳(颗粒度到秒)
  "demand_calc_type": 1,									 // 1-定时任务计算,2-手动触发计算
  "demand_calc_model": 1,									 // 计算模式:1-SNP,2-MPS,3-MRP,4-短期齐套,5-资金计划
  "round_count": 1,												 // 同一时间优先级内run的次数(针对先本工厂再跨工厂的需求)
  "constraint_seq": [1, 2, 3],						 // 约束的顺序表(针对原材料替代组的消耗顺序)
  "population_size": 1000,								 // 种群规模(设置系统参数: CalculatePopulationSize)
  "calc_iterate_count": 10000,						 // 最大迭代次数(设置系统参数: CalculateIterateCountMax)
  "calc_iterate_persist_count": 10,				 // 迭代最优解保持不变(设置系统参数: CalculateIteratePersistCount)
  "calc_sum_time": 3600									 	 // 总计算时长,时间量纲为秒(设置系统参数:CalculateSummaryTime)
}
```

#### 5.1.2 输入计算数据

```json
{
  "message_id": "20240221103710",							          // 消息ID,需保证唯一性("YYYYMMDDHHmmss"格式, 由Java传入)
  "input_demand_list":												          // 需求计划列表
  [
    {
      "demand_id": "demand_id",                         // 需求ID, 唯一标识
      "demand_plan_id": "demand_plan_id",		            // 需求计划号
      "tenant_id": "tenant_01",								          // 租户ID
      "demand_code": "ABC",								  	          // 需求料号(自制件号码)(成品替代中需求以虚构料形式出现)
      "demand_material_list": ["A", "B", "C"],          // 成品/半成品替代组中需求料号列表, 其他时候为空
      "factory_code": "1210",								            // 需求所属工厂号
      "output_date": 20,											          // 产出日期(需求日期=产出日期-lead_time)(建议采用数字)
      "lead_time": 5,												            // 生产提前期(颗粒度到day)
      "demand_gross_quantity": 1000.00,							    // 需求毛需求量(成品替代时,需求数量为替代组中物料期望数量总和;对于WIP预留,毛需求量即为预留数量)
      "demand_type": "PIR",									            // 需求类型, PIR/CIR/Sizing/内部SO/安全库存/DN/WIP(WIP在工厂模型中前处理完成,安全库存在优化算法后处理,不参与优化运算)
      "sample_flag": 1,										              // 样品/量产标识, 1-样品, 0-量产
      "original_priority": 1,								            // 原始优先级, 根据需求优先级分类后的优先级
      "so_no": "so",											  	          // SO号
      "so_item": "so_item",								              // SO Item
      "mo_no": "mo",                                    // MO号(只有需求类型为WIP时会有值,其他类型为空)
      "reserve_stock_loc_code": "l1",                   // MO预留库位号(只有当需求类型为WIP时会有值, WIP预留冲减时优先使用该预留库位)
      "workorder_no": "MTS",						  		          // 任务令号(短期齐套相关)(可以用来区分业务模式, 暂时用不上)
      "bond_flag": 1,											              // 保税标识, 1-保税, 0-非保税
      "stock_loc_relation_list":												// 库位匹配关系列表(与供给数据中库位匹配条件一一对应,否则会报错)
      [
        {
          "relation_id": 1,															 // 关系ID
          "relation_code": "HW",									       // 客户代码(售达方代码)
          "empty_considered_flag": 0										 // 是否考虑为空的情况
        },
        {
          "relation_id": 2,															 // 关系ID
          "relation_code": "01",									       // 销售凭证类型(订单类型)(01为CIR,其他为SO)
          "empty_consider": 0													 	 // 是否考虑为空的情况
        },
        {
          "relation_id": 3,															 // 关系ID
          "relation_code": "ESSD",									     // 产品族(产品业务),ESSD/CSSD/内存/XY主板/小板/SDT/整机….
          "empty_consider": 0													 	 // 是否考虑为空的情况
        },
        {
          "relation_id": 4,															 // 关系ID
          "relation_code": "Z0",									     	 // 产品状态(Z0>Z1>Z2>Z3) Z0(原型机), Z1(样品), Z2(小批量), Z3(量产)
          "empty_consider": 0													 	 // 是否考虑为空的情况
        },
        {
          "relation_id": 5,															 // 关系ID
          "relation_code": "MTS",									     	 // 业务模式, MTS/PCI
          "empty_consider": 0													 	 // 是否考虑为空的情况
        },
        {
          "relation_id": 6,															 // 关系ID
          "relation_code": "1210",									     // 工厂代码
          "empty_consider": 0													 	 // 是否考虑为空的情况
        },
        {
          "relation_id": 7,															 // 关系ID
          "relation_code": "1",									     		 // 保税类型（1/3/5/6/N）
          "empty_consider": 0													 	 // 是否考虑为空的情况
        },
        {
          "relation_id": 8,															 // 关系ID
          "relation_code": "wbs_code",									 // WBS号
          "empty_consider": 0													 	 // 是否考虑为空的情况
        }
      ],
      "stock_loc_exclude_conditions_list":              // 需求排除库位条件列表,结合BOM中「物料属性」「物料组」来匹配可用供给时使用, 对应XY和拆机散件业务
      [
        {
          "material_group": "G1",									      // 物料组
          "production_type": "BS",								      // 生产类型: 对应物料属性(BS/TK)
          "exclude_factory_code": "1211",               // 排除工厂代码
          "exclude_stock_loc_code": "21E3"              // 排除对应「排除工厂代码」下的库位号
        }
      ],
      "support_factory_conditions_list":                // (可选)可跨工厂条件列表,结合BOM中「物料属性」来匹配可用供给时使用, 对应XY和K1业务。为空表示所有工厂都能用,使用跨工厂物料时根据调拨优先级列表查找;不为空表示只能使用factory_code_list中列出的工厂的物料。即可跨工厂条件列表有值,则按可跨工厂列表使用;为空,则按跨工厂调拨优先级列表使用
      [
        {
          "production_type": "BS",								      // 生产类型: 对应物料属性(BS/TK)
          "factory_code_list": ["1210", "1211"]         // 可跨工厂列表(不为空则按优先顺序排列)
        }
      ],
      "transfer_priority_conditions_list":							// 跨工厂调拨优先级条件列表,结合BOM中「物料属性」来匹配可用供给时使用,找到所有的【调拨工厂号】列表, 并按优先级升序排序
      [
        { 
          "production_type": "BS",						  	    // 生产类型: 对应物料属性(BS/TK), 用于匹配调拨优先级
          "factory_code_from": "1213",			  		    // 调拨工厂号(调拨来源工厂)
          "transfer_priority": 1								      // 调拨优先级
        }
      ]
    }
  ],
  "material_supply_list":										            // 物料供给列表
  [
    {
      "materical_code": "mc1",							            // 物料号(可能为成品/半成品/原材料)
      "factory_code": "1210",							              // 工厂号
      "tenant_id": "tenant_01",								          // 租户id
      "material_group": "G1",		                        // 物料组
      "production_type": "BS",					                // 生产类型: 对应物料属性(BS/TK)
      "material_factory_quantity": 1000.00,             // 物料-工厂 供给总量,下层所有类型供给总量之和
      "material_factory_type_list":						          // 物料-工厂-物料供给类型列表, stock/wip/qc/transfer/eta/pr/condominium
      [
        {
          "material_factory_type": 1,					          // 物料供给类型 1-stock,2-dummy,3-qc,4-wip,5-eta,6-pr(手工PR),7-condominium(强共管仓)
          "material_factory_type_quantity": 1000.00,    // 物料-工厂-类型 供给总量,下层所有来源可用数量之和
          "material_factory_type_source_list":          // 类型来源列表
          [
            {
              "stock_loc_code": "id",					          // (必选)库位号
              "sample_flag": 1,		  					          // 样品标识, 1-样品, 0-量产 (与库位相关)
              "bulk_flag": 0,                           // 无限供应标识,无限供应根据物料号+库位号设定;(如果物料供给列表中没有库位号,会自动生成一条含库位的供给数据,在java已经处理好,算法忽略);如果为无限供应,则不考虑可用数量;无限供应也需要考虑【库位约束条件】
              "order_no": "po1",						            // 供给单号,stock/qc/condominium为空,eta-po单号,wip-mo号,transfer-调拨单号
              "so_no": "so",									          // (可选)SO号
              "so_item": "item",							          // (可选)SO Item
              "usable_quantity": 1000.00,		            // 可用数量
              "usable_date": 10,                        // 可用日期(优化计算时按照可用日期)
              "supply_date": 10,  	                    // 供给日期, 对stock/condominium为当前日期,对wip/qc/eta/transfer/pr为供给日期
              "expired_flag": 1,						            // 临超期标识, 1-有超期风险, 0-无超期风险(只有stock会有)
              "datecode": 20,			                      // 最早datecode, 如果有多个批次有超期风险, 则前处理时取最早的一个(只有stock会有)
              "expired_quantity": 200.00,			          // 临超期数量(只有stock会有)
              "bond_flag": 1,										      	// 保税标识, 1-保税, 0-非保税(短期齐套相关)
              "enforced_flag": 1,								      	// (可选)是否强制约束,0-不强制,1-强制,2-空(强制只能使用所有enforced_flag为1的库位;不强制优先使用enforced_flag为0的库位,还可以使用enforced_flag为2的库位)
              "priority_code": 1,							        	// 优先级(可能为空, 如果不为空时按升序排列, 需要结合优先级开始/结束日期使用)
              "priority_effective_from": 5,	            // 优先级开始日期
              "priority_effective_to": 30, 		          // 优先级结束日期 
              "stock_loc_relation_constraints_list":    // 库位匹配关系约束条件集合
              [
                {
                  "relation_id": 1,											// 关系ID
                  "relation_code_list": ["HW", "AL"]		// 客户代码列表(售达方代码列表)
                },
                {
                  "relation_id": 2,											// 关系ID
                  "relation_code_list": ["01", "02"]		// 销售凭证类型列表(订单类型)(01为CIR,其他为SO)
                },
                {
                  "relation_id": 3,											// 关系ID
                  "relation_code_list": ["ESSD", "CSSD"]// 产品族列表(产品业务列表)
                },
                {
                  "relation_id": 4,											// 关系ID
                  "relation_code_list": ["Z0", "Z1"]		// 产品状态列表
                },
                {
                  "relation_id": 5,											// 关系ID
                  "relation_code_list": ["MTS", "PCI"]	// 业务模式型列表
                },
                {
                  "relation_id": 6,											// 关系ID
                  "relation_code_list": ["1210"]	      // 可供需求工厂列表
                },
                {
                  "relation_id": 7,											// 关系ID
                  "relation_code_list": ["1"]	      		// 保税类型（1/3/5/6/N）
                },
                {
                  "relation_id": 8,											// 关系ID
                  "relation_code_list": ["wbs_code"]		// WBS号
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "basic_bom_list":														    // BOM列表
  [
    {
      "demand_code": "D1",                        // 需求料号（顶级料号）
      "factory_code": "1210",								      // 需求所属工厂号
      "so_no": "so",											        // (可选)SO号(如果so号存在, 则按照so号匹配; 如果不存在, 则按需求料号匹配)
      "so_item": "item",									        // (可选)SO Item
      "parent_material_code": "ABC",				      // 父项物料号
      "child_material_code": "A",						      // 子项物料号
      "prd_process": "SMT",						  			    // 子项物料号所属制程段代码
      "complex_flag": 1,                          // 子项物料号是否为复杂BOM标识, 即是否多次出现
      "complex_parent_product_list": ["B", "C"],  // 子项物料号出现在不同父项下(顶层父项相同的BOM),父项为成品料号时,关联父项的所有成品物料号list
      "complex_parent_semi_list": ["B", "C"],     // 子项物料号出现在不同父项下(顶层父项相同的BOM),父项为半成品料号时,关联父项的所有半成品物料号list
      "complex_parent_phantom_list": ["B", "C"],  // 子项物料号出现在不同父项下(顶层父项相同的BOM),父项为虚拟料号时,关联父项的所有虚拟物料号list
      "complex_alternative_list": ["B", "C"],     // 子项物料号为复杂BOM,且位于替代组中时,关联子项物料的所有替代组号list
      "alternative_group": "g1",							    // (可选)替代组号(如果子项物料非替代料, 则替代组号为空)
      "alternative_group_seqnum":1,  					    // (可选)替代料组里顺序号码(如果替代组号为空, 则此处为空)
      "expand_flag": 0,											      // 子项物料是否默认展开(算法用不上，忽略)
      "obsolete_flag": 1,											    // 子项物料是否淘汰料, 0-false, 1-true
      "condominium_usable_flag": 0,               // 子项物料为半成品时,是否可以使用强共管仓类型的供给数据,0-不可用,1-可用
      "bonded_material_flag": 0,									// 保税物料标记,用于给保税订单分配物料时匹配保税仓库物料
      "material_group": "G1",									    // 物料组
      "production_type": "BS",								    // 生产类型: 对应物料属性(BS/TK)
      "lead_time": 5,												      // 提前期, 采购LT与自制LT合并后的提前期(颗粒度到day)
      "base_quantity": 100.00,                    // 基准数量
      "unit_quantity":1.000,								      // 单位用量(单位用量 = 物料需求量 / 基准数量)
      "unit": "",														      // 单位(克/件/个/...)
      "item_valid_from": 1,				                // 有效开始日期, 所有时间都可用则取完整生产日历起止日期
      "item_valid_to": 30					                // 有效结束日期
    }
  ],
  "material_reserve_list":                        // 物料的预留信息列表 ==(待确认)==
  [										
    {
      "demand_code":"p1",						    					// 需求物料号（自制件代码）
      "factory_code":"1201",										  // 所属工厂代码(只针对这个工厂生效)，字符为空代表没有值
      "material_code":"mc1",				    					// 原材料代码(预留的物料)
      "quantity":1000.000,										    // 预留数量
      "reserve_effect_from": 10,				          // 物料预留的开始日期
      "reserve_effect_to": 20					            // 物料预留的结束日期
    }
  ],
  "alternative_material_use_priority_list":       // 替代组物料消耗优先级列表
  [				
    {
      "material_code":"mc1",					            // 自制件代码(有可能针对自制件设置)，字符为空代表没有值
      "factory_code":"1201",										  // 所属工厂代码(只针对这个工厂生效)，字符为空代表没有值
      "use_priority_seq": ["mc2", "mc3"],	        // 替代料组内物料替代顺序表              
      "priority_effect_from": 10,				          // 替代组物料消耗优先级生效的开始日期
      "priority_effect_to": 20					          // 替代组物料消耗优先级生效的结束日期
    }
  ],
  "material_type_priority_list":							    // 物料类型使用优先顺序列表
  [1, 2, 3, 4, 5, 6, 7],													// 1-stock,2-dummy,3-qc,4-wip,5-eta,6-pr(手工PR),7-condominium(强共管仓)
  "production_calendar_list":									    // 生产日历信息列表
  [
    {
      "date": 1,												          // 日期,0表示计算起始天数,往前推移时如果为负数则不考虑非工作日
      "time_priority": 1,													// 时间优先级
      "working_hours": 36000,											// date当天的工时(颗粒度:秒), 0-非工作日, 大于0-工作日
      "title": "202408"											    	// 标题(用不上)
    }
  ]
}
```

### 5.2 输出数据

#### 5.2.1 输出消息数据

```json
{
  "message_id": "20240221103710",								   // 消息ID
  "message_create_time": 1667435400, 	             // ID对应的创建时间 时间戳
  "message_calc_time": 1667467822,			           // 计算开始时间戳(颗粒度到秒)
  "demand_calc_type": 1,								           // 1-定时任务计算,2-手动触发计算
  "demand_calc_model": 1,							             // 计算模式:1-SNP,2-MPS,3-MRP,4-短期齐套,5-资金计划
  "round_count": 1,													 			 // 同一时间优先级内run的次数(针对先本工厂再跨工厂的需求)
  "calc_task_start_time": 1667437200,	             // 任务的计算开始时间 时间戳
  "calc_start_time": 1667437200,				           // 算法计算开始时间 时间戳
  "calc_end_time": 1667439000,					           // 算法计算结束时间 时间戳
  "calc_data_save_time": 1667439120,		           // 计算结果的数据传输时间 时间戳
  "result_message_id": "23456",				             // 计算结果保存的ID
  "result_flag": 0											           // 计算成功/失败标识, 0-失败, 1-成功
}
```



#### 5.2.2 输出计算数据

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403281706613.png" style="zoom:50%;" />

##### 5.2.2.1 SNP&MRP&资金计划（最小化净需求量）

```json
{
  "result_message_id":"23456",								      // 计算结果保存的ID
  "result_code": 1,																	// 计算结果代码:1-净需求结果,2-齐套分配结果,3-缺料分配结果
  "calc_target_result_seq":													// 
  [
    {
      "demand_material_detail_seq":                 // 需求分配序列
      [
        {
          "demand_id": "demand_id",                 // 需求ID, 唯一标识
          "demand_plan_id": "demand_plan_id",	      // 需求计划号(继承自未拆分订单)
          "demand_code": "A",			        				  // 需求料号(自制件号码)(成品替代中需求以虚拟料形式出现)
          "virtual_flag": 0,                        // 是否成品/半成品上层虚拟料, 0-false, 1-true
          "factory_code": "1210",							      // 需求所属工厂号
          "bond_flag": 1,											      // 保税标识, 1-保税, 0-非保税
          "stock_loc_relation_list":								// 库位匹配关系列表(与供给数据中库位匹配条件一一对应)
          [
            {
              "relation_id": 1,							        // 关系ID
              "relation_code": "HW",							  // 客户代码(售达方代码)
              "empty_consider": 0							      // 是否考虑为空的情况
            },
            {
              "relation_id": 2,							        // 关系ID
              "relation_code": "01",							  // 销售凭证类型(订单类型)(01为CIR,其他为SO)
              "empty_consider": 0							      // 是否考虑为空的情况
            }
          ],	
          "stock_loc_exclude_conditions_list":      // 需求排除库位条件列表
          [
            {
              "material_group": "G1",								// 物料组
              "production_type": "BS",							// 生产类型: 对应物料属性(BS/TK)
              "exclude_factory_code": "1211",       // 排除工厂代码
              "exclude_stock_loc_code": "21E3"      // 排除对应「排除工厂代码」下的库位号
            }
          ],
          "support_factory_conditions_list":        // 可跨工厂条件列表
          [
            {
              "production_type": "BS",							// 生产类型: 对应物料属性(BS/TK)
              "factory_code_list": ["1210", "1211"] // 可跨工厂列表
            }
          ],
          "transfer_priority_conditions_list":			// 跨工厂调拨优先级条件列表
          [
            { 
              "production_type": "BS",						  // 生产类型: 对应物料属性(BS/TK), 用于匹配调拨优先级
              "factory_code_from": "1213",			  	// 调拨工厂号(调拨来源工厂)
              "transfer_priority": 1								// 调拨优先级
            }
          ],
          "lead_time": 4,                           // 提前期
          "output_date": 150,					              // 需求产出日期(同输入数据中的output_date)
          "reqeust_date": 146,						          // 组件需求日期,组件需求日期=需求产出日期-提前期
          "original_priority": 1,							      // 原始优先级, 根据需求优先级分类后的优先级
          "calc_priority": 2,											  // 算法优先级, 算法计算完后需求的分配顺序
          "demand_gross_quantity": 1000.00,					// 需求毛需求量
          "demand_net_quantity": 800.00,						// 需求净需求量(需求毛需求量-需求自有库存)
          "assign_material_detail_list":			      // 物料分配明细列表
          [
            {
              "demand_id": "demand_id",             // 需求ID, 唯一标识
          		"demand_plan_id": "demand_plan_id",	  // 需求计划号(继承自需求信息)
              "father_material_id": "00",						// 父项物料ID
              "material_id": "01",                  // 物料ID(BOM中物料的编号,用于标识物料唯一)
              "material_code": "A",					        // 物料代码
              "alternative_group": "",							// (可选)替代组号
      				"alternative_group_seqnum":1,  				// (可选)替代料组里顺序号码
              "lead_time": 4,                       // 提前期
              "material_output_date": 150,					// 物料产出日期
              "material_request_date": 146,					// 组件需求日期,组件需求日期=物料产出日期-生产提前期
              "material_gross_quantity": 1000.00,		// 物料毛需求量(上层净需求量 * 单位用量)
              "assign_material_quantity": 200.00,	  // 物料分配总量(自有库存, 所有工厂分配数量总和)
              "material_net_quantity": 800.00,	    // 物料净需求量
              "calc_unit_quantity": 1.0,					  // 物料计算单位用量(计算单位用量为相对于顶层物料的单位)
              "origin_unit_quantity": 1.0,					// 物料单位用量(单位用量为相对于上层物料的单位)
              "assign_material_factory_list":				// 物料-工厂分配详情列表
              [
                {
                  "source_factory_code": "1210",		          // 物料来源工厂号
                  "assign_factory_quantity": 200.00,          // 工厂分配总量
                  "assign_material_factory_type_list":        // 工厂-物料类型分配详情
                  [
                    {
                      "material_type": 1,		 			 	          // 物料类型
                      "assign_type_quantity": 200.00,         // 类型分配总量
                      "assign_material_type_source_list":
                      [
                        {
                          "demand_id": "demand_id",           // 需求ID, 唯一标识
          								"demand_plan_id": "demand_plan_id",	// 需求计划号(继承自需求信息)
                          "material_id": "01",               	// 物料ID, 继承于上层
                          "stock_loc_code": "L1",             // 物料来源库位,有库位号的就有值
                          "order_no": "",					    	      // 物料来源明细,po单号/mo号/调拨单号
                          "source_assign_quantity":200.00,    // 物料来源分配数量
                          "assign_reason": "",						    // 物料分配原因
                          "bond_flag": 1,										  // 保税标识, 1-保税, 0-非保税(短期齐套相关)
                          "enforced_flag": 1,								  // 是否强制约束
                          "priority_code": 1,							    // 优先级
                          "priority_effective_from": 30,	    // 优先级开始日期
                          "priority_effective_to": 80, 		    // 优先级结束日期
                          "stock_loc_relation_constraints_list":    // 库位匹配关系约束条件集合
                          [
                            {
                              "relation_id": 1,											// 关系ID
                              "relation_code_list": ["HW", "AL"]		// 客户代码列表(售达方代码列表)
                            },
                            {
                              "relation_id": 2,											// 关系ID
                              "relation_code_list": ["01", "02"]		// 销售凭证类型列表(订单类型)
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "demand_id": "demand_id",             // 需求ID, 唯一标识
          		"demand_plan_id": "demand_plan_id",	  // 需求计划号(继承自需求信息)
              "father_material_id": "01",						// 父项物料ID
              "material_id": "02",                  // 物料ID(BOM中物料的编号,用于标识物料唯一)
              "material_code": "B",					        // 物料代码
              "alternative_group": "",							// (可选)替代组号
      				"alternative_group_seqnum":1,  				// (可选)替代料组里顺序号码
              "lead_time": 3,                       // 提前期
              "material_output_date": 146,					// 物料产出日期
              "material_request_date": 143,					// 组件需求日期,组件需求日期=物料产出日期-生产提前期
              "material_gross_quantity": 800.00,		// 物料毛需求量(上层净需求量 * 单位用量)
              "assign_material_quantity": 600.00,	  // 物料分配总量(自有库存, 所有工厂分配数量总和)
              "material_net_quantity": 200.00,	    // 物料净需求量
              "calc_unit_quantity": 1.0,					  // 物料计算单位用量(计算单位用量为相对于顶层物料的单位)
              "origin_unit_quantity": 1.0,					// 物料单位用量(单位用量为相对于上层物料的单位)
              "assign_material_factory_list":       // 物料-工厂分配明细列表(物料分配总量有值才会有明细,否则为空)
              [
                {
                  "source_factory_code": "1210",		          // 物料来源工厂号
                  "assign_factory_quantity": 600.00,          // 工厂分配总量
                  "assign_material_factory_type_list":        // 工厂-物料类型分配详情
                  [
                    {
                      "material_type": 1,		 			 	          // 物料类型
                      "assign_type_quantity": 600.00,         // 类型分配总量
                      "assign_material_type_source_list":
                      [
                        {
                          "demand_id": "demand_id",           // 需求ID, 唯一标识
          								"demand_plan_id": "demand_plan_id",	// 需求计划号(继承自需求信息)
                          "material_id": "02",               	// 物料ID, 继承于上层
                          "stock_loc_code": "L2",             // 物料来源库位,有库位号的就有值
                          "order_no": "",					    	      // 物料来源明细,po单号/mo号/调拨单号
                          "source_assign_quantity":600.00,    // 物料来源分配数量
                          "assign_reason": "",						    // 物料分配原因
                          "bond_flag": 1,										  // 保税标识, 1-保税, 0-非保税(短期齐套相关)
                          "enforced_flag": 1,								  // 是否强制约束
                          "priority_code": 1,							    // 优先级
                          "priority_effective_from": 30,	    // 优先级开始日期
                          "priority_effective_to": 80, 		    // 优先级结束日期
                          "stock_loc_relation_constraints_list":    // 库位匹配关系约束条件集合
                          [
                            {
                              "relation_id": 1,											// 关系ID
                              "relation_code_list": ["HW", "AL"]		// 客户代码列表(售达方代码列表)
                            },
                            {
                              "relation_id": 2,											// 关系ID
                              "relation_code_list": ["01", "02"]		// 销售凭证类型列表(订单类型)
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "demand_id": "demand_id",             // 需求ID, 唯一标识
          		"demand_plan_id": "demand_plan_id",	  // 需求计划号(继承自需求信息)
              "father_material_id": "01",						// 父项物料ID
              "material_id": "03",                  // 物料ID(BOM中物料的编号,用于标识物料唯一)
              "material_code": "C",					        // 物料代码
              "alternative_group": "",							// (可选)替代组号
      				"alternative_group_seqnum":1,  				// (可选)替代料组里顺序号码
              "lead_time": 0,                       // 提前期
              "material_output_date": 146,					// 物料产出日期
              "material_request_date": 146,					// 组件需求日期,组件需求日期=物料产出日期-生产提前期
              "material_gross_quantity": 800.00,		// 物料毛需求量(上层净需求量 * 单位用量)
              "assign_material_quantity": 0.00,	    // 物料分配总量(自有库存, 所有工厂分配数量总和)
              "material_net_quantity": 800.00,	    // 物料净需求量
              "calc_unit_quantity": 1.0,					  // 物料计算单位用量(计算单位用量为相对于顶层物料的单位)
              "origin_unit_quantity": 1.0,					// 物料单位用量(单位用量为相对于上层物料的单位)
              "assign_material_factory_list":       // 物料-工厂分配明细列表(物料分配总量有值才会有明细,否则为空)
              []
            },
            {
              "demand_id": "demand_id",             // 需求ID, 唯一标识
          		"demand_plan_id": "demand_plan_id",	  // 需求计划号(继承自需求信息)
              "father_material_id": "03",						// 父项物料ID
              "material_id": "04",                  // 物料ID(BOM中物料的编号,用于标识物料唯一)
              "material_code": "D",					        // 物料代码
              "alternative_group": "",							// (可选)替代组号
      				"alternative_group_seqnum":1,  				// (可选)替代料组里顺序号码
              "lead_time": 3,                       // 提前期
              "material_output_date": 146,					// 物料产出日期
              "material_request_date": 143,					// 组件需求日期,组件需求日期=物料产出日期-生产提前期
              "material_gross_quantity": 800.00,		// 物料毛需求量(上层净需求量 * 单位用量)
              "assign_material_quantity": 800.00,	  // 物料分配总量(自有库存, 所有工厂分配数量总和)
              "material_net_quantity": 0.00,	      // 物料净需求量
              "calc_unit_quantity": 1.0,					  // 物料计算单位用量(计算单位用量为相对于顶层物料的单位)
              "origin_unit_quantity": 1.0,					// 物料单位用量(单位用量为相对于上层物料的单位)
              "assign_material_factory_list":
              [
                {
                  "source_factory_code": "1210",		          // 物料来源工厂号
                  "assign_factory_quantity": 800.00,          // 工厂分配总量
                  "assign_material_factory_type_list":        // 工厂-物料类型分配详情
                  [
                    {
                      "material_type": 1,		 			 	          // 物料类型
                      "assign_type_quantity": 800.00,         // 类型分配总量
                      "assign_material_type_source_list":
                      [
                        {
                          "demand_id": "demand_id",           // 需求ID, 唯一标识
          								"demand_plan_id": "demand_plan_id",	// 需求计划号(继承自需求信息)
                          "material_id": "04",               	// 物料ID, 继承于上层
                          "stock_loc_code": "L3",             // 物料来源库位,有库位号的就有值
                          "order_no": "",					    	      // 物料来源明细,po单号/mo号/调拨单号
                          "source_assign_quantity":800.00,    // 物料来源分配数量
                          "assign_reason": "",						    // 物料分配原因
                          "bond_flag": 1,										  // 保税标识, 1-保税, 0-非保税(短期齐套相关)
                          "enforced_flag": 1,								  // 是否强制约束
                          "priority_code": 1,							    // 优先级
                          "priority_effective_from": 30,	    // 优先级开始日期
                          "priority_effective_to": 80, 		    // 优先级结束日期
                          "stock_loc_relation_constraints_list":    // 库位匹配关系约束条件集合
                          [
                            {
                              "relation_id": 1,											// 关系ID
                              "relation_code_list": ["HW", "AL"]		// 客户代码列表(售达方代码列表)
                            },
                            {
                              "relation_id": 2,											// 关系ID
                              "relation_code_list": ["01", "02"]		// 销售凭证类型列表(订单类型)
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "calc_target_quantity_seq": 11				                      // 目标函数值
}
```



##### 5.2.2.2 MPS&短期齐套（最大化齐套量）

MPS&短期齐套场景分为两个步骤，输出一份返回消息数据json文件，两份计算输出结果的json文件，通过result_message_id关联：

- Step 1: 需求的最大齐套量及分配详情计算，输出齐套分配信息；
- step 2: 针对需求未齐套部分的最小净需求量计算，输出缺料清单信息；

###### 5.2.2.2.1 齐套分配输出信息

```json
{
  "result_message_id":"23456",								      // 计算结果保存的ID
  "result_code": 2,																	// 计算结果代码:1-净需求结果,2-齐套分配结果,3-缺料分配结果
  "calc_target_result_seq":
  [
    {
      "demand_id": "demand_id",                     // 需求ID, 唯一标识
      "demand_plan_id": "demand_plan_id",	          // 需求计划号(继承自未拆分订单)
      "demand_code": "A",			        				      // 需求料号(自制件号码)(成品替代中需求以虚拟料形式出现)
      "virtual_flag": 0,                            // 是否成品/半成品上层虚拟料, 0-false, 1-true
      "factory_code": "1210",							          // 需求所属工厂号
      "bond_flag": 1,											          // 保税标识, 1-保税, 0-非保税
      "stock_loc_relation_list":								    // 库位匹配关系列表(与供给数据中库位匹配条件一一对应)
      [    
        {    
          "relation_id": 1,							            // 关系ID
          "relation_code": "HW",							      // 客户代码(售达方代码)
          "empty_consider": 0							          // 是否考虑为空的情况
        },    
        {    
          "relation_id": 2,							            // 关系ID
          "relation_code": "01",							      // 销售凭证类型(订单类型)(01为CIR,其他为SO)
          "empty_consider": 0							          // 是否考虑为空的情况
        }    
      ],	    
      "stock_loc_exclude_conditions_list":          // 需求排除库位条件列表 
      [    
        {    
          "material_group": "G1",								    // 物料组
          "production_type": "BS",							    // 生产类型: 对应物料属性(BS/TK)
          "exclude_factory_code": "1211",           // 排除工厂代码
          "exclude_stock_loc_code": "21E3"          // 排除对应「排除工厂代码」下的库位号
        }    
      ],    
      "support_factory_conditions_list":            // 可跨工厂条件列表
      [
        {
          "production_type": "BS",							    // 生产类型: 对应物料属性(BS/TK)
          "factory_code_list": ["1210", "1211"]     // 可跨工厂列表
        }    
      ],    
      "transfer_priority_conditions_list":			    // 跨工厂调拨优先级条件列表
      [    
        {     
          "production_type": "BS",						      // 生产类型: 对应物料属性(BS/TK), 用于匹配调拨优先级
          "factory_code_from": "1213",			  	    // 调拨工厂号(调拨来源工厂)
          "transfer_priority": 1								    // 调拨优先级
        }    
      ],    
      "lead_time": 4,                               // 提前期
      "output_date": 150,					                  // 需求产出日期(同输入数据中的output_date)
      "reqeust_date": 146,						              // 组件需求日期,组件需求日期=需求产出日期-提前期
      "original_priority": 1,							          // 原始优先级, 根据需求优先级分类后的优先级
      "calc_priority": 2,											      // 算法优先级, 算法计算完后需求的分配顺序
      "demand_gross_quantity": 1000.00,					    // 需求毛需求量
      "kitting_quantity": 800.00,					          // 需求齐套数量(需求齐套量 = 自有库存 + 下层齐套供给)
      "non_kitting_quantity": 200,                  // 需求未齐套量(未齐套量 = 毛需求量 - 齐套数量),算完齐套量之后更新
      "kitting_demand_material_detail_list":        // 齐套分配结果（让料结果）
      [
        {
          "assign_material_detail_list":			      // 物料分配明细列表
          [
            {
              "demand_id": "demand_id",             // 需求ID, 唯一标识
          		"demand_plan_id": "demand_plan_id",	  // 需求计划号(继承自需求信息)
              "father_material_id": "00",						// 父项物料ID
              "material_id": "01",                  // 物料ID(BOM中所有的编号,用于标识物料唯一)
              "material_code": "A",					        // 物料代码
              "alternative_group": "",							// (可选)替代组号
      				"alternative_group_seqnum":1,  				// (可选)替代料组里顺序号码
              "lead_time": 4,                       // 提前期
              "material_output_date": 150,					// 物料产出日期
              "material_request_date": 146,					// 组件需求日期,组件需求日期=物料产出日期-生产提前期
              "material_kitting_quantity": 800.00,	// 物料齐套数量（下层供给产生的齐套量 + 自有库存供给量）
              "assign_material_quantity": 200.00,	  // 物料分配总量(使用自有库存的数量, 所有工厂分配数量总和)
              "calc_unit_quantity": 1.0,					  // 物料计算单位用量(计算单位用量为相对于顶层物料的单位)
              "origin_unit_quantity": 1.0,					// 物料单位用量(单位用量为相对于上层物料的单位)
              "assign_material_factory_list":       // 物料-工厂分配明细列表(物料分配总量有值才会有明细,否则为空)
              [
                {
                  "source_factory_code": "1210",		          // 物料来源工厂号
                  "assign_factory_quantity": 200.00,          // 工厂分配总量
                  "assign_material_factory_type_list":        // 工厂-物料类型分配详情
                  [
                    {
                      "material_type": 1,		 			 	          // 物料类型
                      "assign_type_quantity": 200.00,         // 类型分配总量
                      "assign_material_type_source_list":
                      [
                        {
                          "demand_id": "demand_id",           // 需求ID, 唯一标识
          								"demand_plan_id": "demand_plan_id",	// 需求计划号(继承自需求信息)
                          "material_id": "01",               	// 物料ID, 继承于上层
                          "stock_loc_code": "L1",             // 物料来源库位,有库位号的就有值
                          "order_no": "",					    	      // 物料来源明细,po单号/mo号/调拨单号
                          "source_assign_quantity":200.00,    // 物料来源分配数量
                          "assign_reason": "",						    // 物料分配原因
                          "bond_flag": 1,										  // 保税标识, 1-保税, 0-非保税(短期齐套相关)
                          "enforced_flag": 1,								  // 是否强制约束
                          "priority_code": 1,							    // 优先级
                          "priority_effective_from": 30,	    // 优先级开始日期
                          "priority_effective_to": 80, 		    // 优先级结束日期
                          "stock_loc_relation_constraints_list":    // 库位匹配关系约束条件集合
                          [
                            {
                              "relation_id": 1,											// 关系ID
                              "relation_code_list": ["HW", "AL"]		// 客户代码列表(售达方代码列表)
                            },
                            {
                              "relation_id": 2,											// 关系ID
                              "relation_code_list": ["01", "02"]		// 销售凭证类型列表(订单类型)
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "demand_id": "demand_id",               // 需求ID, 唯一标识
          		"demand_plan_id": "demand_plan_id",	    // 需求计划号(继承自需求信息)
              "father_material_id": "01",							// 父项物料ID
              "material_id": "02",                    // 物料ID(BOM中所有物料的编号,用于标识物料唯一)
              "material_code": "B",					          // 物料代码
              "alternative_group": "",								// (可选)替代组号
      				"alternative_group_seqnum":1,  					// (可选)替代料组里顺序号码
              "lead_time": 3,                         // 提前期
              "material_output_date": 146,					  // 物料产出日期
              "material_request_date": 143,					  // 组件需求日期,组件需求日期=物料产出日期-生产提前期
              "material_kitting_quantity": 600.00,		// 物料齐套数量（下层供给产生的齐套量 + 自有库存供给量）
              "assign_material_quantity": 600.00,	    // 物料分配总量(自有库存, 所有工厂分配数量总和)
              "calc_unit_quantity": 1.0,					    // 物料计算单位用量(计算单位用量为相对于顶层物料的单位)
              "origin_unit_quantity": 1.0,					  // 物料单位用量(单位用量为相对于上层物料的单位)
              "assign_material_factory_list":         // 物料-工厂分配明细列表(物料分配总量有值才会有明细,否则为空)
              [
                {
                  "source_factory_code": "1210",		          // 物料来源工厂号
                  "assign_factory_quantity": 600.00,          // 工厂分配总量
                  "assign_material_factory_type_list":        // 工厂-物料类型分配详情
                  [
                    {
                      "material_type": 1,		 			 	          // 物料类型
                      "assign_type_quantity": 600.00,         // 类型分配总量
                      "assign_material_type_source_list":
                      [
                        {
                          "demand_id": "demand_id",           // 需求ID, 唯一标识
          								"demand_plan_id": "demand_plan_id",	// 需求计划号(继承自需求信息)
                          "material_id": "02",               	// 物料ID, 继承于上层
                          "stock_loc_code": "L2",             // 物料来源库位,有库位号的就有值
                          "order_no": "",					    	      // 物料来源明细,po单号/mo号/调拨单号
                          "source_assign_quantity":600.00,    // 物料来源分配数量
                          "assign_reason": "",						    // 物料分配原因
                          "bond_flag": 1,										  // 保税标识, 1-保税, 0-非保税(短期齐套相关)
                          "enforced_flag": 1,								  // 是否强制约束
                          "priority_code": 1,							    // 优先级
                          "priority_effective_from": 30,	    // 优先级开始日期
                          "priority_effective_to": 80, 		    // 优先级结束日期
                          "stock_loc_relation_constraints_list":    // 库位匹配关系约束条件集合
                          [
                            {
                              "relation_id": 1,											// 关系ID
                              "relation_code_list": ["HW", "AL"]		// 客户代码列表(售达方代码列表)
                            },
                            {
                              "relation_id": 2,											// 关系ID
                              "relation_code_list": ["01", "02"]		// 销售凭证类型列表(订单类型)
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "demand_id": "demand_id",               // 需求ID, 唯一标识
          		"demand_plan_id": "demand_plan_id",	    // 需求计划号(继承自需求信息)
              "father_material_id": "01",							// 父项物料ID
              "material_id": "03",                    // 物料ID(BOM中所有物料的编号,用于标识物料唯一)
              "material_code": "C",					          // 物料代码
              "alternative_group": "",								// (可选)替代组号
      				"alternative_group_seqnum":1,  					// (可选)替代料组里顺序号码
              "lead_time": 0,                         // 提前期
              "material_output_date": 146,					  // 物料产出日期
              "material_request_date": 146,					  // 组件需求日期,组件需求日期=物料产出日期-生产提前期
              "material_kitting_quantity": 20000,			// 物料齐套数量（下层供给产生的齐套量 + 自有库存供给量）
              "assign_material_quantity": 0.00,	      // 物料分配总量(自有库存, 所有工厂分配数量总和)
              "calc_unit_quantity": 1.0,					    // 物料计算单位用量(计算单位用量为相对于顶层物料的单位)
              "origin_unit_quantity": 1.0,					  // 物料单位用量(单位用量为相对于上层物料的单位)
              "assign_material_factory_list":         // 物料-工厂分配明细列表(物料分配总量有值才会有明细,否则为空)
              []
            },
            {
              "demand_id": "demand_id",               // 需求ID, 唯一标识
          		"demand_plan_id": "demand_plan_id",	    // 需求计划号(继承自需求信息)
              "father_material_id": "03",							// 父项物料ID
              "material_id": "04",                    // 物料ID(BOM中所有物料的编号,用于标识物料唯一)
              "material_code": "D",					          // 物料代码
              "alternative_group": "",								// (可选)替代组号
      				"alternative_group_seqnum":1,  					// (可选)替代料组里顺序号码
              "lead_time": 3,                         // 提前期
              "material_output_date": 146,					  // 物料产出日期
              "material_request_date": 143,					  // 组件需求日期,组件需求日期=物料产出日期-生产提前期
              "material_kitting_quantity": 20000.00,	// 物料齐套数量（下层供给产生的齐套量 + 自有库存供给量）
              "assign_material_quantity": 600.00,	    // 物料分配总量(自有库存, 所有工厂分配数量总和)
              "calc_unit_quantity": 1.0,					    // 物料计算单位用量(计算单位用量为相对于顶层物料的单位)
              "origin_unit_quantity": 1.0,					  // 物料单位用量(单位用量为相对于上层物料的单位)
              "assign_material_factory_list":         // 物料-工厂分配明细列表(物料分配总量有值才会有明细,否则为空)
              [
                {
                  "source_factory_code": "1210",		          // 物料来源工厂号
                  "assign_factory_quantity": 800.00,          // 工厂分配总量
                  "assign_material_factory_type_list":        // 工厂-物料类型分配详情
                  [
                    {
                      "material_type": 1,		 			 	          // 物料类型
                      "assign_type_quantity": 600.00,         // 类型分配总量
                      "assign_material_type_source_list":
                      [
                        {
                          "demand_id": "demand_id",           // 需求ID, 唯一标识
          								"demand_plan_id": "demand_plan_id",	// 需求计划号(继承自需求信息)
                          "material_id": "04",               	// 物料ID, 继承于上层
                          "stock_loc_code": "L3",             // 物料来源库位,有库位号的就有值
                          "order_no": "",					    	      // 物料来源明细,po单号/mo号/调拨单号
                          "source_assign_quantity":600.00,    // 物料来源分配数量
                          "assign_reason": "",						    // 物料分配原因
                          "bond_flag": 1,										  // 保税标识, 1-保税, 0-非保税(短期齐套相关)
                          "enforced_flag": 1,								  // 是否强制约束
                          "priority_code": 1,							    // 优先级
                          "priority_effective_from": 30,	    // 优先级开始日期
                          "priority_effective_to": 80, 		    // 优先级结束日期
                          "stock_loc_relation_constraints_list":    // 库位匹配关系约束条件集合
                          [
                            {
                              "relation_id": 1,											// 关系ID
                              "relation_code_list": ["HW", "AL"]		// 客户代码列表(售达方代码列表)
                            },
                            {
                              "relation_id": 2,											// 关系ID
                              "relation_code_list": ["01", "02"]		// 销售凭证类型列表(订单类型)
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "calc_target_quantity_seq": 11				                      // 目标函数值
}
```

###### 5.2.2.2.2 缺料清单输出信息

```json
{
  "result_message_id":"23456",								      // 计算结果保存的ID
  "result_code": 3,																	// 计算结果代码:1-净需求结果,2-齐套分配结果,3-缺料分配结果
  "calc_target_result_seq":
  [
    {
      "demand_id": "demand_id",                     // 需求ID, 唯一标识
      "demand_plan_id": "demand_plan_id",	          // 需求计划号(继承自未拆分订单)
      "demand_code": "A",			        				      // 需求料号(自制件号码)(成品替代中需求以虚拟料形式出现)
      "virtual_flag": 0,                            // 是否成品/半成品上层虚拟料, 0-false, 1-true
      "factory_code": "1210",							          // 需求所属工厂号
      "bond_flag": 1,											          // 保税标识, 1-保税, 0-非保税
      "stock_loc_relation_list":								    // 库位匹配关系列表(与供给数据中库位匹配条件一一对应)
      [    
        {    
          "relation_id": 1,							            // 关系ID
          "relation_code": "HW",							      // 客户代码(售达方代码)
          "empty_consider": 0							          // 是否考虑为空的情况
        },    
        {    
          "relation_id": 2,							            // 关系ID
          "relation_code": "01",							      // 销售凭证类型(订单类型)(01为CIR,其他为SO)
          "empty_consider": 0							          // 是否考虑为空的情况
        }    
      ],	    
      "stock_loc_exclude_conditions_list":          // 需求排除库位条件列表 
      [    
        {    
          "material_group": "G1",								    // 物料组
          "production_type": "BS",							    // 生产类型: 对应物料属性(BS/TK)
          "exclude_factory_code": "1211",           // 排除工厂代码
          "exclude_stock_loc_code": "21E3"          // 排除对应「排除工厂代码」下的库位号
        }    
      ],    
      "support_factory_conditions_list":            // 可跨工厂条件列表
      [
        {
          "production_type": "BS",							    // 生产类型: 对应物料属性(BS/TK)
          "factory_code_list": ["1210", "1211"]     // 可跨工厂列表
        }    
      ],    
      "transfer_priority_conditions_list":			    // 跨工厂调拨优先级条件列表
      [    
        {     
          "production_type": "BS",						      // 生产类型: 对应物料属性(BS/TK), 用于匹配调拨优先级
          "factory_code_from": "1213",			  	    // 调拨工厂号(调拨来源工厂)
          "transfer_priority": 1								    // 调拨优先级
        }    
      ],    
      "lead_time": 4,                               // 提前期
      "output_date": 150,					                  // 需求产出日期(同输入数据中的output_date)
      "reqeust_date": 146,						              // 组件需求日期,组件需求日期=需求产出日期-提前期
      "original_priority": 1,							          // 原始优先级, 根据需求优先级分类后的优先级
      "calc_priority": 2,											      // 算法优先级, 算法计算完后需求的分配顺序
      "demand_gross_quantity": 200.00,					    // 需求毛需求量
      "demand_net_quantity": 200.00,						    // 需求净需求量(需求毛需求量-需求自有库存)
      "assign_material_detail_list":			          // 物料分配明细列表
      [
        {
          "assign_material_detail_list":			      // 物料分配明细列表
          [
            {
              "demand_id": "demand_id",             // 需求ID, 唯一标识
              "demand_plan_id": "demand_plan_id",	  // 需求计划号(继承自需求信息)
              "father_material_id": "",							// 父项物料ID
              "material_id": "01",                  // 物料ID(BOM中所有物料的编号,用于标识物料唯一)
              "material_code": "A",					        // 物料代码
              "alternative_group": "",							// (可选)替代组号
              "alternative_group_seqnum":1,  				// (可选)替代料组里顺序号码
              "lead_time": 4,                       // 提前期
              "material_output_date": 150,					// 物料产出日期
              "material_request_date": 146,					// 组件需求日期,组件需求日期=物料产出日期-生产提前期
              "material_gross_quantity": 200.00,		// 物料毛需求量(上层净需求量 * 单位用量)
              "assign_material_quantity": 0.00,	    // 物料分配总量(自有库存, 所有工厂分配数量总和)
              "material_net_quantity": 200.00,	    // 物料净需求量
              "calc_unit_quantity": 1.0,					  // 物料计算单位用量(计算单位用量为相对于顶层物料的单位)
              "origin_unit_quantity": 1.0,					// 物料单位用量(单位用量为相对于上层物料的单位)
              "assign_material_factory_list":       // 物料-工厂分配明细列表(物料分配总量有值才会有明细,否则为空)
              []
            },
            {
              "demand_id": "demand_id",             // 需求ID, 唯一标识
              "demand_plan_id": "demand_plan_id",	  // 需求计划号(继承自需求信息)
              "father_material_id": "01",						// 父项物料ID
              "material_id": "02",                  // 物料ID(BOM中所有物料的编号,用于标识物料唯一)
              "material_code": "B",					        // 物料代码
              "alternative_group": "",							// (可选)替代组号
              "alternative_group_seqnum":1,  				// (可选)替代料组里顺序号码
              "lead_time": 3,                       // 提前期
              "material_output_date": 146,					// 物料产出日期
              "material_request_date": 143,					// 组件需求日期,组件需求日期=物料产出日期-生产提前期
              "material_gross_quantity": 200.00,		// 物料毛需求量((顶层物料毛需求量1000-齐套数量800)*计算单位用量)
              "assign_material_quantity": 0.00,	    // 物料分配总量(自有库存, 所有工厂分配数量总和)
              "material_net_quantity": 200.00,	    // 物料净需求量(物料毛需求量 - 物料分配总量)
              "calc_unit_quantity": 1.0,					  // 物料计算单位用量(计算单位用量为相对于顶层物料的单位)
              "origin_unit_quantity": 1.0,					// 物料单位用量(单位用量为相对于上层物料的单位)
              "assign_material_factory_list":       // 物料-工厂分配明细列表(物料分配总量有值才会有明细,否则为空)
              []
            },
            {
              "demand_id": "demand_id",               // 需求ID, 唯一标识
              "demand_plan_id": "demand_plan_id",	    // 需求计划号(继承自需求信息)
              "father_material_id": "01",							// 父项物料ID
              "material_id": "03",                    // 物料ID(BOM中所有物料的编号,用于标识物料唯一)
              "material_code": "C",					          // 物料代码
              "alternative_group": "",								// (可选)替代组号
              "alternative_group_seqnum":1,  					// (可选)替代料组里顺序号码
              "lead_time": 0,                         // 提前期
              "material_output_date": 146,					  // 物料产出日期
              "material_request_date": 146,					  // 组件需求日期,组件需求日期=物料产出日期-生产提前期
              "material_gross_quantity": 200.00,		  // 物料毛需求量(上层净需求量 * 单位用量)
              "assign_material_quantity": 0.00,	      // 物料分配总量(自有库存, 所有工厂分配数量总和)
              "material_net_quantity": 200.00,	      // 物料净需求量
              "calc_unit_quantity": 1.0,					    // 物料计算单位用量(计算单位用量为相对于顶层物料的单位)
              "origin_unit_quantity": 1.0,					  // 物料单位用量(单位用量为相对于上层物料的单位)
              "assign_material_factory_list":         // 物料-工厂分配明细列表(物料分配总量有值才会有明细,否则为空)
              []
            },
            {
              "demand_id": "demand_id",               // 需求ID, 唯一标识
              "demand_plan_id": "demand_plan_id",	    // 需求计划号(继承自需求信息)
              "father_material_id": "03",							// 父项物料ID
              "material_id": "04",                    // 物料ID(BOM中所有物料的编号,用于标识物料唯一)
              "material_code": "D",					          // 物料代码
              "alternative_group": "",								// (可选)替代组号
              "alternative_group_seqnum":1,  					// (可选)替代料组里顺序号码
              "lead_time": 3,                         // 提前期
              "material_output_date": 146,					  // 物料产出日期
              "material_request_date": 143,					  // 组件需求日期,组件需求日期=物料产出日期-生产提前期
              "material_gross_quantity": 200.00,		  // 物料毛需求量(上层净需求量 * 单位用量)
              "assign_material_quantity": 200.00,	    // 物料分配总量(自有库存, 所有工厂分配数量总和)
              "material_net_quantity": 0.00,	        // 物料净需求量
              "calc_unit_quantity": 1.0,					    // 物料计算单位用量(计算单位用量为相对于顶层物料的单位)
              "origin_unit_quantity": 1.0,					  // 物料单位用量(单位用量为相对于上层物料的单位)
              "assign_material_factory_list":         // 物料-工厂分配明细列表(物料分配总量有值才会有明细,否则为空)
              [
                {
                  "source_factory_code": "1210",		          // 物料来源工厂号
                  "assign_factory_quantity": 200.00,          // 工厂分配总量
                  "assign_material_factory_type_list":        // 工厂-物料类型分配详情
                  [
                    {
                      "material_type": 1,		 			 	          // 物料类型
                      "assign_type_quantity": 200.00,         // 类型分配总量
                      "assign_material_type_source_list":
                      [
                        {
                          "demand_id": "demand_id",           // 需求ID, 唯一标识
                          "demand_plan_id": "demand_plan_id",	// 需求计划号(继承自需求信息)
                          "material_id": "04",               	// 物料ID, 继承于上层
                          "stock_loc_code": "L3",             // 物料来源库位,有库位号的就有值
                          "order_no": "",					    	      // 物料来源明细,po单号/mo号/调拨单号
                          "source_assign_quantity":200.00,    // 物料来源分配数量
                          "assign_reason": "",						    // 物料分配原因
                          "bond_flag": 1,										  // 保税标识, 1-保税, 0-非保税(短期齐套相关)
                          "enforced_flag": 1,								  // 是否强制约束
                          "priority_code": 1,							    // 优先级
                          "priority_effective_from": 30,	    // 优先级开始日期
                          "priority_effective_to": 80, 		    // 优先级结束日期
                          "stock_loc_relation_constraints_list":    // 库位匹配关系约束条件集合
                          [
                            {
                              "relation_id": 1,											// 关系ID
                              "relation_code_list": ["HW", "AL"]		// 客户代码列表(售达方代码列表)
                            },
                            {
                              "relation_id": 2,											// 关系ID
                              "relation_code_list": ["01", "02"]		// 销售凭证类型列表(订单类型)
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ],
  "calc_target_quantity_seq": 11				                      // 目标函数值
}
```



## 6. 工厂模型

**假设条件：**

1. 优化计算的BOM包括四种类型：需求BOM (ProductBom), 半成品BOM (SemiBom), 替代组BOM (AlternateBom), 原材料BOM (NormalBom):

   - 半成品BOM指的是所有可以展开的物料，不局限于业务含义的“半成品”;

   - 原材料BOM指的是所有不可以展开的物料，不局限于业务含义的“原材料”;

   - 需求BOM中可以包含类型为：半成品、替代组、原材料;

   - 半成品BOM中可以包含类型为：半成品、替代组、原材料;

   - 替代组BOM中包含类型为：成品、半成品、原材料，不包含替代组;

   - 原材料BOM中不包含其他类型;

2. 同一替代组内不能同时存在原材料和非原材料;

3. 正常情况下缺料选择不考虑淘汰料，但是如果同一替代组内全都是淘汰料，则产生缺料时随机选择一颗物料;

4. 每类`m_ProductionType`最多只有一条匹配项，即最多只有一条「可跨工厂列表」数据;

5. 「可跨工厂列表」如果存在，则需求的工厂号（`demand.m_FactoryCode`）一定存在于「可跨工厂列表」中，且位于首位，后续工厂代码也是有序的；
6. 记忆科技项目最大化齐套量模型和最小化净需求量模型都是单目标优化问题；
7. 保税订单齐套量为0且不缺料的场景合理；

<table style="width: 100%; border: none; background-color: white">
    <tr style="border: none;">
        <td style="border: none; text-align: center;">
           <img src="https://gitee.com/uc4334/imgs/raw/master/img/202404150930019.png" style="zoom:50%;" />
            <div style="margin-top: 10px; font-size: 16px; color: #333;">图1 算法主流程</div>
        </td>
    </tr>
</table>



### 6.1 WIP预留处理（生产订单预留）

**假设条件**：

- WIP预留处理为优化算法前处理，WIP类型需求不参与优化计算；

- WIP类型需求以原材料形式给出，由于原材料不存在BOM，因此为了构建BOM结构会虚构出一个上层虚构料作为父项物料号，子项物料号为WIP类型需求对应的原材料号（==Java处理==）。

- WIP类型需求以原材料作为需求，毛需求量作为预留数量；

- 对于WIP类型的需求，调用优化算法中的【计算齐套量】的接口计算每个需求齐套量；

- 齐套计算调用优化算法中的【计算齐套量】的接口，获取可用供给来源是从三个维度考虑：

  - 「物料号 + 工厂号 + 库位号」：只匹配物料号+工厂号+库位号，忽略其他约束条件；

  - 「物料号 + 工厂号 + 库位约束条件」：使用【获取可用供给来源】接口；

  - 「物料号 + 库位约束条件」：使用【获取可用供给来源】接口；


### 6.1 需求准备

从输入的json文件中的`input_demand`结构转化成优化计算使用的`demand_info`结构

输入：`input_demand_list`

输出：`std::vector<DemandInfo> demand_info_pool`

处理：

- 计算需求日期：需求日期 = 产出日期 - 提前期（需要结合生产日历）；
- 计算需求的时间优先级：匹配需求日期在生产日历中对应的时间优先级；

### 6.2 BOM准备

- SNP场景的BOM中不包含原材料；

- SNP场景下，针对替代组，构建一个上层虚拟料，计算净需求量时落在该虚拟料上，不继续往下扩展；

- 如果需求找不到BOM（即顶层物料找不到），则写入日志记录，跳过该需求，最后参与优化计算的是所有能够找到BOM的需求；

- 匹配BOM时候，参考是否往下展开的字段`expand_flag`，如果`expand_flag = 1`继续往下找，但是没找到BOM，就忽略，不做报错或者抛出异常处理；

- BOM数据准备过程（Java处理）
  SNP：
  过滤掉所有原材料的BOM
  过滤掉基于[半成品替代组生成的虚拟阶]对应除[下层的第一层半成品]以外的所有物料

  MPR、资金预测
  过滤掉SNP输出BOM结构中，子项为[半成品替代组生成的虚拟阶]的数据
  过滤掉SNP输出BOM结构中，父项不为[半成品替代组生成的虚拟阶]且按父子物料组合关系在SNP输出BOM结构存在的数据

  MPS、短期齐套
  直接传递完整BOM结构

<table style="width: 100%; border: none; background-color: white">
    <tr style="border: none;">
        <td style="border: none; text-align: center;">
           <img src="https://gitee.com/uc4334/imgs/raw/master/img/202404161622811.png" style="zoom:15%;" />
            <div style="margin-top: 10px; font-size: 16px; color: #333;">图4 需求的BOM匹配过程</div>
        </td>
    </tr>
</table>



#### 6.2.1 需求分类

按照BOM匹配所需属性将需求分配，以便相同属性的需求可以共享同一份BOM，减少内存开销。



```c++
// so信息
class SoInfo
{
public:
    bool operator==(const SoInfo &other) const
    {
        if ((this->m_SoNo == other.m_SoNo) && (this->m_SoItem == other.m_SoItem))
        {
            return true;
        }
        return false;
    }
public:
    std::string m_SoNo;   // 需求所属So
    std::string m_SoItem; // 需求所属So_item
};
class NormalMaterial
{
public:
    std::string m_MaterialCode;          // 物料号
    std::optional<SoInfo> m_SoInfo;      // so信息
    int m_LeadTime;                      // 提前期(颗粒度到day)
    BomItemValidAttr m_BomItemValidAttr; // BOM有限期属性
};

class SemiBomInfo
{
public:
    std::map<std::string, NormalMaterial> m_NormalMaterialPool;                          // 正常物料信息表
    std::map<std::string, std::shared_ptr<SemiBomInfo>> m_SemiBomInfoPool;               // 半成品物料信息表
    std::map<std::string, std::shared_ptr<AlternativeBomInfo>> m_AlternativeBomInfoPool; // 替代组物料信息表
public:
    std::string m_MaterialCode;          // 物料代码
    std::optional<SoInfo> m_SoInfo;      // so信息
    int m_LeadTime;                      // 提前期(颗粒度到day)
    BomItemValidAttr m_BomItemValidAttr; // BOM有限期属性
};

class AlternativeBomInfo
{
public:
    std::map<std::string, NormalMaterial> m_NormalMaterialPool;                          // 正常物料信息表
    std::map<std::string, std::shared_ptr<SemiBomInfo>> m_SemiBomInfoPool;               // 半成品物料信息表
public:
    std::string m_MaterialCode;          // 物料代码(替代组号)
};

class ProductBomInfo
{
public:
    std::map<std::string, NormalMaterial> m_NormalMaterialPool;                          // 正常物料信息表
    std::map<std::string, std::shared_ptr<SemiBomInfo>> m_SemiBomInfoPool;               // 半成品物料信息表
    std::map<std::string, std::shared_ptr<AlternativeBomInfo>> m_AlternativeBomInfoPool; // 替代组物料信息表

public:
    std::string m_MaterialCode;          // 物料代码(需求料号)
    std::optional<SoInfo> m_SoInfo;      // so信息
    int m_LeadTime;                      // 提前期(颗粒度到day)
    BomItemValidAttr m_BomItemValidAttr; // BOM有限期属性
};
// 输入需求数据信息
class DemandInfo
{
public:
  std::shared_ptr<ProductBomInfo> m_SpProductBomInfo; // 需求的Bom结构
public:
    std::string m_DemandId;                                                 // 需求ID, 唯一标识
    std::string m_DemandCode;                                               // 需求料号(自制件号码)
    std::string m_FactoryCode;                                              // 需求所属工厂号
    int m_OutputDate;                                                       // 产出日期
    int m_LeadTime;                                                         // 生产提前期(颗粒度到day)
    std::optional<SoInfo> m_SoInfo;                                         // so信息
};
// 替代组信息
class AlternativeGroupInfo
{
public:
    std::string m_AlternativeGroup;    // 替代组代码
    uint16_t m_AlternativeGroupSeqnum; // 替代料组顺序号码
};
// BOM有限期属性
class BomItemValidAttr
{
public:
    // 检查给定的日期是否在有效期范围内
    bool IsDateWithinRange(int date) const
    {
        return date >= this->m_ItemValidFrom && date <= this->m_ItemValidTo;
    }
public:
    int m_ItemValidFrom; // 有效开始日期
    int m_ItemValidTo;   // 有效结束日期
};
// 输入BOM数据信息
class InputBomInfo
{
public:
    std::string m_DemandCode;                                             // 需求料号
    std::string m_FactoryCode;                                            // 工厂号
    std::optional<SoInfo> m_SoInfo;                                       // so信息
    std::string m_ParentMaterialCode;                                     // 父项物料号
    std::string m_MaterialCode;                                           // 子项物料号
    std::optional<AlternativeGroupInfo> m_AlternativeGroupInfo;           // 替代组信息
    bool m_ExpandFlag;                                                    // 子项物料是否继续展开
    int m_LeadTime;                                                       // 提前期(颗粒度到day)
    BomItemValidAttr m_BomItemValidAttr;                                  // BOM有限期属性
};
```

**Algorithm** 1: 构建输入BOM信息索引（CreateInputBomInfoIndex）

**输入**：

- `inputBomInfos`：输入BOM信息列表，类型为`std::vector<InputBomInfo>`，包含所有待匹配的BOM项。

**输出**：

- `bomInfoIndex`：BOM信息索引，类型为`std::map<std::string, std::vector<InputBomInfo>>`，键为由工厂代码和需求料号构成的字符串，值为与键匹配的`InputBomInfo`对象列表。

**过程**：

1. **初始化索引**：创建一个空的`std::map<std::string, std::vector<InputBomInfo>>`作为索引。
2. 填充索引：
   1. 遍历`inputBomInfos`中的每个`InputBomInfo`对象。
   2. 对每个对象，构造一个键，格式为`工厂代码_需求料号`。
   3. 将该对象添加到索引的对应键下的列表中。



**Algorithm** 2: 匹配并构建需求的BOM结构（MatchBomForDemands）

**输入**：

- `demands`：需求信息列表，类型为`std::vector<DemandInfo>`，包含所有待处理的需求。
- `bomInfoIndex`：通过Algorithm 1构建的BOM信息索引。

**输出**：

- 需求列表`demands`将被更新，每个需求项内部的BOM结构根据匹配的`InputBomInfo`进行构建和更新。

**过程**：

1. 遍历需求列表：对于demands中的每个demand：
   1. 初始化`demand`的BOM结构（`m_SpProductBomInfo`）为新的`ProductBomInfo`对象。
   2. 计算`demand`的组件需求日期`requestDate`，使用`demand`的产出日期减去生产提前期。
   3. 根据`demand`的工厂代码和需求料号，在`bomInfoIndex`中查找匹配的`InputBomInfo`列表。
2. 对匹配的BOM项进行处理：
   1. 对于每个找到的`InputBomInfo`对象，通过Algorithm 3（下文描述）判断是否满足加入条件。
   2. 如果满足，通过Algorithm 4（下文描述）更新`demand`的BOM结构。



**Algorithm** 3: 判断匹配条件（IsMatch）

**输入**：

- `inputBom`：待判断的`InputBomInfo`对象。
- `demand`：当前处理的`DemandInfo`对象。
- `requestDate`：需求的组件需求日期。

**输出**：

- 布尔值，指示`inputBom`是否满足加入到`demand`的BOM结构中的条件。

**过程**：

1. **检查工厂代码**：如果`inputBom.m_FactoryCode`与`demand.m_FactoryCode`不匹配，返回`false`。
2. 按SO信息匹配：
   1. 如果`inputBom`和`demand`都有SO信息且匹配，并且`requestDate`在`inputBom`的有效期内，返回`true`。
3. 按需求料号匹配：
   1. 如果`inputBom.m_DemandCode`与`demand.m_DemandCode`匹配，并且`requestDate`在`inputBom`的有效期内，返回`true`。
4. 如果以上条件都不满足，返回`false`。



**Algorithm** 4: 更新需求BOM结构（ProcessInputBom）

**输入**：

- `inputBom`：匹配的`InputBomInfo`对象，已通过Algorithm 3判断满足条件。
- `parentBom`：父BOM结构，初次调用时为`demand`的`m_SpProductBomInfo`。
- `bomInfoIndex`：BOM信息索引，用于查找子物料信息。

**输出**：

- 无直接输出。`parentBom`将根据`inputBom`的信息进行更新，可能包括添加新的物料信息或递归更新子物料。

**过程**：

1. 检查是否可以展开：
   1. 如果`inputBom.m_ExpandFlag`为`true`，表示该物料可以展开，构建相应的`SemiBomInfo`或`AlternativeBomInfo`对象，并递归处理其子物料。
2. 更新父BOM结构：
   1. 根据`inputBom`的属性（如是否属于替代组）将物料信息添加到`parentBom`的相应容器中。
3. 递归处理子物料：
   1. 如果`inputBom`表示的物料可以展开，查找该物料的所有子物料并递归调用Algorithm 4进行处理。







algorithm 1: 需求BOM匹配

输入：

- 需求列表：`std::vector<DemandInfo> demand_info_pool`,
- 输入bom信息列表： `std::vector<InputBomInfo> input_bom_info_pool`;

输出：void，更新需求的BOM结构，`std::shared_ptr<ProductBomInfo> m_SpProductBomInfo;` 

匹配条件：

1. 首次：parent = demand：
   1. 计算parent的组件需求日期：parent.m_MaterialRequestDate = parent.m_MaterialOutputDate -parent.m_LeadTime;
   2. 查找parent的子项物料的input_bom，并装入相应的容器；
   3. 如果input_bom.m_ExpandFlag == true可以展开，则将input_bom.m_MaterialCode作为parentMaterialCode,继续匹配找下层bom数据，直到子项物料不可展开（input_bom.m_ExpandFlag == false）。
2. 后续parent = child；
   1. 计算parent的组件需求日期：parent.m_MaterialRequestDate = parent.m_MaterialOutputDate -parent.m_LeadTime;
   2. 查找parent的子项物料的input_bom，并装入相应的容器；
   3. 如果input_bom.m_ExpandFlag == true可以展开，则将input_bom.m_MaterialCode作为parentMaterialCode,继续匹配找下层bom数据，直到子项物料不可展开（input_bom.m_ExpandFlag == false）。



algorithm 2: 查找parent的子项物料的input_bom

输入：parent,  `std::vector<InputBomInfo> input_bom_info_pool`;

输出：

过程：

对于ProductBomInfo的下层子项物料：

如果下层子项物料存在替代组信息：

- 如果下层子项物料不可展开，且子项物料符合匹配条件，则写入ProductBomInfo的m_AlternativeBomInfoPool中的m_NormalMaterialPool中；
- 如果下层子项物料可以展开，且子项物料符合匹配条件，则写入ProductBomInfo的m_AlternativeBomInfoPool中的m_SemiBomInfoPool中；

如果下层子项物料不存在替代组信息：

- 如果下层子项物料不可展开，且子项物料符合匹配条件，则写入ProductBomInfo的m_NormalMaterialPool中；
- 如果下层子项物料可以展开，且子项物料符合匹配条件，则写入ProductBomInfo的m_SemiBomInfoPool中；



对于SemiBomInfoPool下层子项物料：

如果下层子项物料存在替代组信息：

- 如果下层子项物料不可展开，且子项物料符合匹配条件，则写入SemiBomInfoPool的m_AlternativeBomInfoPool中的m_NormalMaterialPool中；
- 如果下层子项物料可以展开，且子项物料符合匹配条件，则写入SemiBomInfoPool的m_AlternativeBomInfoPool中的m_SemiBomInfoPool中；

如果下层子项物料不存在替代组信息：

- 如果下层子项物料不可展开，且子项物料符合匹配条件，则写入SemiBomInfoPool的m_NormalMaterialPool中；
- 如果下层子项物料可以展开，且子项物料符合匹配条件，则写入SemiBomInfoPool的m_SemiBomInfoPool中；



algorithm 3: 子项物料匹配条件

输入：parent,  input_bom_info;

输出：

过程：

1. 工厂号匹配：parent.m_FactoryCode == input_bom.m_FactoryCode；
2. 按SO匹配：
   1. 如果parent的需求料号与input_bom的需求料号匹配 且 parent的so信息与input_bom的so信息匹配 且 parent.m_MaterialRequestDate满足input_bom的有效期约束：则表示能匹配，返回true；
3. 需求料号匹配：
   1. 如果parent的需求料号与input_bom的需求料号匹配 且 parent.m_MaterialRequestDate满足input_bom的有效期约束：则表示能匹配，返回true；
4. 如果都不能匹配，则返回false。



如果 input_bom.m_ParentMaterialCode == demand.m_DemandCode, 则将对应的子项物料写入ProductBomInfo结构。

如果input_bom.m_ExpandFlag == true可以展开，则将input_bom.m_MaterialCode作为parentMaterialCode,继续匹配找下层bom数据，直到子项物料不可展开（input_bom.m_ExpandFlag == false）。



对于ProductBomInfo的下层子项物料：

如果下层子项物料存在替代组信息：

- 如果下层子项物料不可展开，则写入ProductBomInfo的m_AlternativeBomInfoPool中的m_NormalMaterialPool中；
- 如果下层子项物料可以展开，则写入ProductBomInfo的m_AlternativeBomInfoPool中的m_SemiBomInfoPool中；

如果下层子项物料不存在替代组信息：

- 如果下层子项物料不可展开，则写入ProductBomInfo的m_NormalMaterialPool中；
- 如果下层子项物料可以展开，则写入ProductBomInfo的m_SemiBomInfoPool中；



查找ProductBomInfo：

1. demand.m_FactoryCode == input_bom.m_FactoryCode;
2. demand.m_DemandCode == input_bom.m_ParentMaterialCode;
3. demand.m_SoInfo如果存在，则优先匹配input_bom中m_SoInfo存在且相同的bom数据；
4. demand.m_RequestDate符合input_bom的有效期约束；



通过上层物料(parent)查找下层物料(child)：

1. 工厂号匹配：demand.m_FactoryCode == input_bom.m_FactoryCode；
2. 如果 input_bom.m_ParentMaterialCode == demand.m_DemandCode：
   1. parent_material_code = demand.m_DemandCode;
   2. 计算组件需求日期: parent.m_MaterialRequestDate = demand.m_OutputDate - demand.m_LeadTime;
   3. 如果demand.m_SoInfo存在：
      1. 

      2. SO匹配：
         1. 有效期约束满足：
            1. BOM展开：
            2. BOM不展开：
         2. 有效期约束不满足：

      3. SO不匹配：

   4. 如果demand.m_SoInfo不存在：
      1. 需求料号匹配：
         1. 有效期约束满足：
            1. BOM展开：
            2. BOM不展开：

         2. 有效期约束不满足：

      2. 需求料号不匹配：输出信息“找不到BOM”

3. 如果 input_bom.m_ParentMaterialCode != demand.m_DemandCode：
   1. 

4. 将input_bom.m_MaterialCode作为parentMaterialCode,继续匹配找下层bom数据；
5. 计算parent.m_MaterialRequestDate: 
   1. 如果parent.m_MaterialCode == demand.m_DemandCode, parent.m_MaterialRequestDate = demand.m_OutputDate - demand.m_LeadTime;
   2. 否则，parent.m_MaterialRequestDate = parent.m_MaterialOutputDate -parent.m_LeadTime;

6. 按SO匹配：m_SoInfo如果存在，则优先匹配input_bom中m_SoInfo存在且相同的bom数据；
7. 按需求料号匹配：
8. 有效期约束：
9. ProductBomInfo的RequestDate等于上层RequestDate - m_LeadTime，匹配的时候也需要符合下层bom数据的有效期约束；
10. 

#### 6.2.2 物料产出日期/组件需求日期计算

#### 6.2.3 BOM匹配规则

##### 6.2.3.1 按so信息匹配

##### 6.2.3.2 按需求料号匹配

#### 6.2.3 优化计算的BOM构建

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403251825980.png" style="zoom:50%;" />



### 6.3 需求分配流程（优化算法）

- 该过程为优化算法计算过程中的需求分配顺序需要遵循的原则；
- 参与优化计算的需求类型不包括【WIP类型】；
  - 对于【安全库存】，由于可能存在成品安全库存，因此先尝试参与优化运算；
  - 如果对于性能影响较大，则【安全库存】在优化算法后做后处理；


- 需求序列按照「时间优先级」「需求日期」「原始优先级」分组；

- 优化计算时相同「时间优先级」「需求日期」「原始优先级」的需求可以改变顺序，其他情况不允许；

  

  <img src="https://gitee.com/uc4334/imgs/raw/master/img/202404142345724.png" style="zoom:50%;" />

#### 6.3.1 需求序列构造

##### 6.3.1.1 初始解构造

初始解的需求序列构造遵守「时间优先级」「需求日期」「原始优先级」「需求ID」顺序。

##### 6.3.1.2 优化解构造

初始解的需求序列构造遵守「时间优先级」「需求日期」「原始优先级」顺序，







### 6.4 替代组物料使用优先级

#### 6.4.1 原材料替代组

##### 6.4.1.1 消耗排序规则

替代组内原材料按上述【原材料替代组排序规则】排序，按顺序消耗原材料时，结合【6.6 可用供给来源消耗顺序】考虑N型消耗。

<table style="width: 100%; border: none; background-color: white">
    <tr style="border: none;">
        <td style="border: none; text-align: center;">
            <img src="https://gitee.com/uc4334/imgs/raw/master/img/202403251518097.png" style="zoom:50%;" />
            <div style="margin-top: 10px; font-size: 16px; color: #333;">图7 原材料替代组使用优先级</div>
        </td>
    </tr>
</table>


如下图所示，假设替代组内有R1, R2, R3三颗原材料，按照【原材料替代组排序规则】排序后，使用顺序为R2 > R1 > R3

物料类型共有7种，根据【6.6 可用供给来源消耗顺序】，分别为stock > qc > wip > eta > transfer > pr > condominium

则针对原材料替代组的消耗顺序为：R2.stock > R1.stock > R3.stock > R2.qc > R1.qc > R1.qc > ...

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403131020206.png" style="zoom:50%;" />

##### 6.4.1.2 缺量选择排序规则

对于原材料替代组来说，如果所有物料都消耗完之后仍有缺量，则需要再考虑缺量放置在替代组中的哪颗物料上。

由于淘汰料不会产生净需求，因此在缺料选择的时候排除淘汰料，**需要保证替代组中至少有一颗物料不是淘汰料**。

剩余物料按如下规则排序再决策最终缺量选择的物料。

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403291115247.png" style="zoom:50%;" />



#### 6.4.2 非原材料替代组

针对非原材料的替代组（即成品替代/半成品替代/虚拟料替代），首先消耗自有库存来满足替代组的需求量，如果所有物料的自有库存消耗完还不足以满足替代组的需求量，则再考虑下层齐套量供给。

此外，针对以最小化净需求量为目标的场景（SNP/MRP/资金计划），如果存在替代组需求缺量，则还需进行缺量选择排序，决策缺量需要分配到替代组内哪一颗物料上。

因此，针对非原材料的替代组从3个方面考虑排序规则，由此执行物料按顺序分配，流程如下图所示。

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403131402003.png"  style="zoom:80%;" />

##### 6.4.2.1 自有库存消耗排序规则

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403201408740.png" style="zoom:50%;" />

针对非原材料的替代组，成品和半成品可能会存在自有库存，因此在计算替代料消耗顺序时需要优先考虑自有库存量，虚拟料无自有库存量。

成品和半成品的库存类型中只会有stock和wip的可用量可能有值，其中wip类型还有可用日期，其他类型可用量都为0。

在消耗成品/半成品的自有库存量时，同样需要结合【6.6 可用供给来源消耗顺序】考虑N型消耗。

**自有库存使用排序规则**：

- 类型优先级：stock > wip；
- 按可用日期升序；
- 按可用数量降序；
- 按指定优先消耗顺序升序；
- 按优先级(`alternative_group_seqnum`)升序；
- 按物料编码升序；

如下图所示，假设替代组内有P1, P2, P3三颗成品物料以及它们对应的不同类型的库存量。

应用【自有库存使用排序规则】，则针对成品替代组的消耗顺序为：P3.stock > P1.stock > P2.stock > P1.wip > P2.wip

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403131453347.png" style="zoom:50%;" />

##### 6.4.2.2 非自有库存消耗排序规则

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403201409628.png" style="zoom:50%;" />

如果消耗完替代组内物料的自有库存量后，替代组的需求量仍未被满足，则继续使用各个物料的下层齐套量来满足替代组需求缺量。

使用各个物料的下层齐套量来满足替代组需求缺量时，需要重新调整替代组内物料的使用顺序。

计算替代组内每个物料的齐套数量，并标记单颗物料齐套量是否能满足替代组需求缺量，再按照如下排序规则。

**非自有库存使用排序规则**：

- 按指定优先消耗顺序升序；
- 单科物料齐套量能满足替代组需求缺量优先；
- 替代组中物料按优先级(`alternative_group_seqnum`)升序；
- 替代组中物料按齐套量降序；
- 替代组中物料按物料编码升序；

##### 6.4.2.3 缺量选择排序规则（最小化净需求使用）

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403131601797.png" style="zoom:50%;" />

针对以最小化净需求量为目标的场景（SNP/MRP/资金计划），在经过替代组内物料自有库存量分配和齐套量分配后，替代组需求量未满足时，再决定替代组需求缺量（即替代组剩余需求量）选择的时候，同样需要重新调整缺量选择顺序。

分别计算替代组内每个物料满足替代组需求缺量时的下层原材料净需求量，再按照如下规则排序。

**缺量选择排序规则**

- 下层原材料净需求量升序；
- 替代组中物料按优先级(`alternative_group_seqnum`)升序；
- 替代组中物料按物料编码升序；



如下图所示，假设替代组中有A/B/C三颗半成品物料，替代组需求量为100，A/B/C齐套数量分别为20/30/40，

则替代组需求缺量为100 - (20 + 30 + 40) = 10

以10为替代组需求缺量，分别计算A/B/C下层原材料的净需求量：

假设A下层原材料有A1/A2，库存量分别为0/0；B下层原材料有B1/=B2，库存量分别为10/0；C下层原材料有C1/C2，库存量分别为5/0；

则满足替代组需求缺量10的条件下，原材料净需求量：

A: A1: 10 - 0 = 10, A2: 10 - 0 = 10, 原材料净需求量 = 10 (A1) + 10 (A2) = 20; 

B: B1: 10 - 0 = 10, B2: 10 - 10 = 0, 原材料净需求量 =  10 (B1) + 0 (B2) = 10; 

C: C1: 10 - 5 = 5, C2: 10 - 0 = 10, 原材料净需求量 = 5 (C1) + 10 (C2) = 15; 

应用【缺量选择排序规则】，针对替代组的缺量选择顺序为: B > C > A。

故将替代组需求缺量10分配给B。

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403081359549.png" style="zoom:18%;" />



### 6.5 获取可用供给来源

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202404011755888.png" style="zoom:50%;" />

需求BOM展开后，确定了使用某一物料后，紧接着需要获取物料的可用供给来源。

如果物料的需求日期为负数，则只能使用第0天的物料。



```c++
// 需求库位匹配关系约束
class DemandStockLocRelation
{
public:
    uint8_t m_RelationId;       // 关系ID
    std::string m_RelationCode; // 关系代码
    bool m_EmptyConsideredFlag; // 是否考虑供给数据中「关系代码列表」为空的情况
};
// 需求库位约束条件
class DemandStockLocConstraintConditions
{
public:
  bool m_BondFlag;                                                  // 保税标识
  std::vector<DemandStockLocRelation> m_DemandStockLocRelationList; // 库位匹配关系约束条件列表
};
// 库位排除条件
class StockLocExcludeCondition
{
public:
    std::string m_MaterialGroup;       // 物料组
    std::string m_ProductionType;      // 生产类型: 对应物料属性(BS/TK)
    std::string m_ExcludeFactoryCode;  // 排除工厂代码
    std::string m_ExcludeStockLocCode; // 排除对应「排除工厂代码」下的库位号
};
// 可支持工厂条件
class SupportFactoryCondition
{
public:
    std::string m_ProductionType;               // 生产类型: 对应物料属性(BS/TK)
    std::vector<std::string> m_FactoryCodeList; // 可跨工厂列表
};
// 调拨优先级条件
class TransferPriorityCondition
{
public:
    std::string m_ProductionType;  // 生产类型: 对应物料属性(BS/TK)
    std::string m_FactoryCodeFrom; // 调拨工厂号(调拨来源工厂)
    uint16_t m_TransferPriority;   // 调拨优先级
};

// Bom信息
class Bom
{
public:
  std::string m_MaterialCode;   // 物料代码
  bool m_CondominiumUsableFlag; // 是否可以使用强供管仓类型的供给数据
  bool m_BondedMaterialFlag;    // 保税物料标记
  std::string m_MaterialGroup;  // 物料组
  std::string m_ProductionType; // 生产类型: 对应物料属性(BS/TK)
};

// 需求信息
class Demand
{
public:
  std::string m_DemandCode;     // 需求料号
  std::string m_FactoryCode;    // 工厂号
  bool m_SampleFlag;            // 样品/量产标识
  std::vector<Bom> m_BomList;		// BOM物料集合
  int m_RequestDate;            // 组件需求日期
  DemandStockLocConstraintConditions m_DemandStockLocConstraintConditions; // 库位匹配条件
  std::vector<StockLocExcludeCondition> m_StockLocExcludeConditionList;    // 需求排除库位条件列表
  std::vector<SupportFactoryCondition> m_SupportFactoryConditionList;      // 可跨工厂条件列表
  std::vector<TransferPriorityCondition> m_TransferPriorityConditionList;  // 调拨优先级条件列表
};

// 来源优先级信息
class SourcePriorityInfo
{
public:
    uint16_t m_PriorityCode;     // 优先级
    int m_PriorityEffectiveFrom; // 优先级开始日期
    int m_PriorityEffectiveTo;   // 优先级结束日期
};
// 库位匹配关系约束条件
class StockLocRelationConstraint
{
public:
    uint8_t m_RelationId;                        // 关系ID
    std::vector<std::string> m_RelationCodeList; // 关系代码列表
};
// 物料-工厂-类型-来源 信息
class MaterialFactoryTypeSourceSupplyInfo
{
public:
  std::string m_StockLocCode;                                               // 库位号
  bool m_SampleFlag;                                                        // 样品标识
  bool m_BulkFlag;                                                          // 无限供应标识,无限供应根据物料号+库位号设定
  std::string m_OrderNo;                                                    // 供给单号
  double m_UsableQuantity;                                                  // 可用数量
  int m_UsableDate;                                                         // 可用日期(优化计算时按照可用日期)
  bool m_ExpiredFlag;                                                       // 临超期标识
  int m_Datecode;                                                           // 最早datecode
  double m_ExpiredQuantity;                                                 // 临超期数量(只有stock会有)
  bool m_BondFlag;                                                          // 保税标识
  std::optional<bool> m_EnforcedFlag;                                       // 是否强制约束, 0-不强制, 1-强制
  SourcePriorityInfo m_SourcePriorityInfo;                   								// 来源优先级信息
  std::vector<StockLocRelationConstraint> m_StockLocRelationConstraintList; // 库位匹配关系约束条件集合
};
// 物料-工厂-类型 信息
class MaterialFactoryTypeSupplyInfo
{
public:
    uint8_t m_MaterialFactoryType;  // 物料供给类型 1-stock,2-dummy,3-qc,4-wip,5-eta,6-pr(手工PR),7-condominium(强共管仓)
    double m_MaterialFactoryTypeSupplyQuantity;  // 物料-工厂-类型 供给总量,下层所有来源可用数量之和
    std::vector<MaterialFactoryTypeSourceSupplyInfo> m_MaterialFactoryTypeSourceSupplyInfoList; // 物料-工厂-类型-来源 列表
};
// 输入供给数据信息
class InputSupplyInfo
{
public:
    std::string m_MaterialCode;                                                     // 物料号
    std::string m_FactoryCode;                                                      // 工厂号
    std::string m_TenantId;                                                         // 租户ID
    std::string m_MaterialGroup;                                                    // 物料组
    std::string m_ProductionType;                                                   // 生产类型: 对应物料属性(BS/TK)
    double m_MaterialFactorySupplyQuantity;                                         // 物料-工厂 供给总量,下层所有类型供给总量之和
    std::vector<MaterialFactoryTypeSupplyInfo> m_MaterialFactoryTypeSupplyInfoList; // 物料-工厂-物料供给类型列表
};
```



**Algorithm 1.1**: 获取需求BOM工厂使用优先级列表（只针对原材料）

**假设条件：**

- 该方法只适用于bom为原材料类型。
- 针对非原材料类型的bom，只能使用本工厂物料，因此获取可用供给来源的时候直接传入本工厂代码。

**输入**：

- `demand`: 需求信息
- `demand.bom`: 包含需求物料信息的BOM（物料清单）

**输出**：需求BOM数据的工厂使用优先级列表`available_factory_order_list`

**过程**：

1. **初始化优先顺序列表：** 创建一个空列表`available_factory_order_list`以存储根据各条件筛选后的工厂使用优先级列表。
2. **检查可跨工厂条件：**
   1. 若需求的 `m_SupportFactoryConditionList`不为空，则执行以下步骤：
      1. **假设条件：** 
         1. 每类`m_ProductionType`最多只有一条匹配项，即最多只有一条「可跨工厂列表」数据；
         2. 「可跨工厂列表」如果存在，需求工厂（`demand.m_FactoryCode`）存在于列表中，且在 `factory_code_list` 中的首位。
      2. 遍历  `m_SupportFactoryConditionList`，对于每个条件：
         1. 如果 BOM数据的 `m_ProductionType` 与条件的 `m_ProductionType` 匹配，则「工厂使用优先级列表」即为「可跨工厂列表」，即`available_factory_order_list = factory_code_list`。
      3.  如果遍历完成后没有找到任何匹配项，则将需求指定的本工厂代码（`demand.m_FactoryCode`）添加到 `available_factory_order_list`，跳至步骤 3。
   2. 若需求的 `m_SupportFactoryConditionList`为空，则将需求指定的本工厂代码（`demand.m_FactoryCode`）添加到 `available_factory_order_list`，跳至步骤 3。
3. **检查调拨优先级条件：**
   1. 若需求的` m_TransferPriorityConditionList`不为空，则执行以下步骤：
     1. 遍历 ` m_TransferPriorityConditionList`，对于每个条件：
        1. 如果 BOM数据的 `m_ProductionType` 与条件的 `m_ProductionType` 匹配，则按 `m_TransferPriority` 升序，将对应的调拨来源工厂代码（`m_FactoryCodeFrom`）添加到 `available_factory_order_list` 列表中，注意避免重复添加。

   2. 若需求的` m_TransferPriorityConditionList`为空，则跳至步骤 4。

4. **最终检查：**
   1. 确保`available_factory_order_list`列表至少包含一个工厂代码。

5. **返回结果：** 输出根据上述条件筛选和排序后的需求BOM数据的工厂使用优先顺序列表`available_factory_order_list`。

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202404080949246.png" style="zoom:80%;" />

进一步，需求BOM工厂使用优先级列表需要根据round_count不同返回不同的值。

**Algorithm 1.2**: 根据round_count及当前run_index获取需求BOM工厂使用优先级列表（只针对原材料）

**输入：**

- `round_count`: 总的run的次数（目前暂定总run次数最多2次）
- `run_index`: 当前run的轮次

**输出：**当前run_index下需求BOM的工厂使用优先级列表

**过程：**

1. 如果`round_count == 1`:
   1. 如果`demand.bom`为非原材料，`工厂使用优先级列表 = {本工厂代码}`；
   2. 如果`demand.bom`为原材料，
      1. 可跨工厂列表不为空: `工厂使用优先级列表 = 可跨工厂列表`；
      2. 可跨工厂列表为空: `工厂使用优先级列表 = {本工厂代码} + 跨工厂调拨列表`；

2. 如果`round_count == 2`:
   1. 如果`run_index == 1`:
      1. 如果`demand.bom`为非原材料，`工厂使用优先级列表 = {本工厂代码}`；
      2. 如果`demand.bom`为原材料，
         1. 可跨工厂列表不为空: `工厂使用优先级列表 = 可跨工厂列表`；
         2. 可跨工厂列表为空: `工厂使用优先级列表 = {本工厂代码}`；
   2. 如果`run_index == 2`:
      1. 如果`demand.bom`为非原材料，`工厂使用优先级列表 = {}`；
      2. 如果`demand.bom`为原材料，
         1. 可跨工厂列表不为空: `工厂使用优先级列表 = {}`；
         2. 可跨工厂列表为空: `工厂使用优先级列表 = 跨工厂调拨列表`；



<img src="https://gitee.com/uc4334/imgs/raw/master/img/202404091349916.png" style="zoom:50%;" />



**Algorithm 2**: 获取排除工厂库位

**输入**：

- `demand`: 需求信息
- `demand.bom`: 包含需求物料信息的BOM（物料清单）
- `target_factory_code`: 目标工厂代码

**输出**：

- 需求BOM中的某颗物料在目标工厂的排除库位列表`excluded_stock_loc_list`

**过程**：

1. **初始化排除库位列表:** 创建一个空列表`excluded_stock_loc_list`用以存储排除的库位代码。
2. **分析排除库位条件：**
   1. 如果需求信息中的`m_StockLocExcludeConditionList`为空，意味着没有特定的排除库位条件。此时，算法结束，返回空的`excluded_stock_loc_list`。
   2. 如果`m_StockLocExcludeConditionList`非空，对列表中的每个`StockLocExcludeCondition`条目进行如下操作：
      1. **工厂代码匹配：**
         1. 如果排除工厂代码等于目标工厂代码，即`demand.m_ExcludeFactoryCode == target_factory_code`，进行**物料条件匹配**；
         2. 如果不等于，忽略当前条目，继续遍历下一个条目。
      2. **物料条件匹配：**
         1. 检查条目中的`m_MaterialGroup`和`m_ProductionType`是否分别与`demand.bom.m_MaterialGroup`和`demand.bom.m_ProductionType`相匹配。
            1. 如果两者均匹配，表明此条目适用于排除库位，将条目的`m_ExcludeStockLocCode`加入到`excluded_stock_loc_list`中。
            2. 继续遍历`m_StockLocExcludeConditionList`中的下一个`StockLocExcludeCondition`条目，直至列表遍历完成。
3. **返回结果:** 算法结束，返回`excluded_stock_loc_list`，其中包含了所有根据需求信息和目标工厂筛选出的排除库位代码。



**Algorithm 3**: 查找对应工厂可用供给来源

**输入**：

- `demand`: 需求信息

- `demand.bom`: 包含需求物料信息的BOM（物料清单）
- `target_factory_code`: 目标工厂代码
- `excluded_stock_loc_list`: 需要排除的库位列表，基于特定的需求约束
- `supply_list`: 包含所有可用供给信息的列表

**输出**：

- `available_supply_list`: 经过筛选后的满足所有条件的供给数据项列表。

**过程**：

1. **初始化可用供给来源列表：** 

   1. 创建一个空列表`available_supply_list`用以存储筛选后的供给来源数据。
   2. 创建两个临时空列表`forced_available_supply_list`和`unforced_available_supply_list`用以临时存储供给来源数据。

2. **筛选匹配的供给数据：** 对供给数据列表进行遍历，对于每一条供给数据，执行以下条件匹配检查：

   1. **物料代码匹配：**`demand.bom.m_MaterialCode == supply.m_MaterialCode`，则继续步骤2.2；否则，跳过当前供给数据，返回步骤2，继续对下一条供给数据进行检查。

   2. **可用时间检查：**

      1. 对于最大化齐套量场景，做可用时间检查：
         1. 对于特殊情况（`demand.bom.m_RequestDate < 0`），只能使用立即可用的供给，即`supply.m_UsableDate = 0`，则继续步骤2.3；
         2. 对于一般情况（`demand.bom.m_RequestDate >= 0`），确保供给的可用日期不晚于需求日期，即`demand.bom.m_RequestDate >= supply.m_UsableDate`，则继续步骤2.3；
         3. 如果上述条件均不满足，表示当前供给数据不符合时间要求，跳过该数据，返回步骤2，继续对下一条供给数据进行检查。

      2. 对于最小化净需求量场景，不做该项检查。

   3. **目标工厂匹配：**`target_factory_code == supply.m_FactoryCode`，则继续步骤2.4；否则，跳过当前供给数据，返回步骤2，继续对下一条供给数据进行检查。

   4. **排除特定库位：** 若`supply.m_StockLocCode`不在`excluded_stock_loc_list`中，则继续步骤2.5；否则，跳过当前供给数据，返回步骤2，继续对下一条供给数据进行检查。

   5. **强共管仓约束：**若`demand.bom.m_CondominiumUsableFlag == false`且`supply.m_MaterialFactoryType == 7`，则跳过当前供给数据，返回步骤2，继续对下一条供给数据进行检查；否则，继续步骤2.6。

   6. **保税与非保税需求处理：**

      1. 如果`demand.m_BondFlag == true`，并且`demand.bom.m_BondedMaterialFlag == false`，即**保税订单的非保税物料**，则只考虑非保税供给数据，即要求`supply.m_BondFlag == false`，则继续步骤2.7；否则，跳过当前供给数据，返回步骤2，继续对下一条供给数据进行检查。
      2. 如果`demand.m_BondFlag == false`，即**非保税订单**，则只考虑非保税供给数据，即要求`supply.m_BondFlag == false`，则继续步骤2.7；否则，跳过当前供给数据，返回步骤2，继续对下一条供给数据进行检查。

   7. **样品/量产需求处理：**

      1. 如果`demand.m_SampleFlag = false`，即需求为**量产的订单**，只能使用量产来源物料。即要求`supply.m_SampleFlag == false`，则继续步骤2.8；否则，跳过当前供给数据，返回步骤2，继续对下一条供给数据进行检查。

   8. **库位关系匹配：**

      1. 如果需求的库位匹配关系列表`demand.m_DemandStockLocRelationList`不为空，表示需求中指定了库位匹配关系，需对每个供给项进行检查。遍历需求的库位匹配关系列表，对于每一项库位匹配关系，执行以下检查：

         1. **关系ID匹配：**

            遍历供给数据的库位匹配关系约束条件集合`supply.m_StockLocRelationConstraintList`，如果找到与`demand.m_RelationId`对应的`supply.m_RelationId`，则继续步骤2.8.1.2进行下一步**关系代码匹配**；否则，跳过当前供给数据，返回步骤2，继续对下一条供给数据进行检查。

         2. **关系代码匹配：**

            1. 如果`demand.m_RelationCode`包含在`supply.m_RelationCodeList`中，或`supply.m_RelationCodeList`为空，则表示该条供给数据符合匹配条件，进入步骤2.9进行强制约束处理。
            2. 如果`demand.m_RelationCode`不包含在`supply.m_RelationCodeList`中，则跳过当前供给数据，返回步骤2，继续对下一条供给数据进行检查。

      2. 如果需求的库位匹配关系列表`demand.m_DemandStockLocRelationList`为空，表示没有指定库位匹配关系，不需进行库位关系匹配，继续步骤2.9。

   9. **强制约束处理：**

      1. 如果`supply.m_EnforcedFlag`存在且`supply.m_EnforcedFlag == true`，则将该供给数据加入强制约束列表`forced_available_supply_list`中。
      2. 如果`supply.m_EnforcedFlag`不存在或`supply.m_EnforcedFlag == false`，则将该供给数据加入非强制约束列表`unforced_available_supply_list`中。
      3. 返回步骤2，继续对下一条供给数据进行检查。

3. **获取可用供给列表**：

   1. 如果`forced_available_supply_list`不为空，则可用供给来源列表`available_supply_list = forced_available_supply_list`。
   2. 否则，则可用供给来源列表`available_supply_list = unforced_available_supply_list`。
   3. 进入步骤4针对`available_supply_list`按如下规则排序。

4. **返回结果：**返回排序后的`available_supply_list`。



**Algorithm 4:** 可用供给来源排序

**输入：**`available_supply_list`可用供给来源列表

**输出：**排序后的可用供给来源列表`available_supply_list`

**过程：**

1. 物料供给类型`supply.m_MaterialFactoryType`升序；
2. 替代组内物料的使用顺序（如果不是替代组内物料，该条规则也不会影响排序）;
3. 物料来源优先级中的`supply.m_PriorityCode`升序；
4. 物料来源库位代码`supply.m_StockLocCode`升序；



### 6.6 可用供给来源消耗顺序

同一物料同一工厂内的供给来源，根据物料类型按如下顺序消耗：

1-stock, 2-dummy, 3-qc, 4-wip, 5-eta, 6-pr(手工PR), 7-condominium(强供管仓)

### 6.7 安全库存处理

（暂时不做特殊处理）

### 6.8 保税约束处理

- 齐套分配场景下，需求所有物料分配完成之后做保税约束检查，以满足保税订单至少分配一颗保税物料的约束。

- 如果需求为保税需求且「保税约束满足标识」为false，则齐套量为0。

- 最小化净需求场景下，不做保税约束检查。如果替代组中同时存在保税物料和非保税物料，替代料使用排序规则导致保税物料排在非保税物料后面，可能会存在某个需求齐套量为0，但是又不缺料，场景合理。

```pseudocode
Algorithm 1: 保税订单约束处理
输入: demand, bom
输出: 更新的demand对象和物料分配状态
流程:

bool m_BondedSatisfiedFlag = false

foreach bomItem in demand.m_BomList do
  if (demand.m_BondFlag == true && bomItem.m_BondedMaterialFlag == true) then		// 保税订单的保税物料
      // 获取可用供给来源列表
      
      if IsExist(保税仓库物料) then
        m_BondedSatisfiedFlag = true

if (m_BondedSatisfiedFlag == false) then
	kitting_qty = 0
```

### 6.9 复杂BOM处理



## 7. ACO for Ramaxel

### 7.1 算法概述

蚁群优化算法（ACO）是一种启发式搜索算法，受到自然界蚂蚁寻找食物路径的行为启发。通过模拟蚂蚁放置和追随信息素的机制，ACO能够解决复杂的组合优化问题。该算法特别适合解决如路径规划、调度、分类等问题，因为这些问题可以通过搜索最优路径或序列来建模。

蚁群算法利用简单的蚂蚁个体之间的间接通信（通过信息素）来发现问题的最优解。每只蚂蚁探索解空间，根据遇到路径上的信息素浓度来选择下一步，同时也在走过的路径上留下信息素，指示该路径的优良程度。随着时间的推移，高质量的路径上积累了更多的信息素，从而吸引更多的蚂蚁。这种正反馈循环最终使得算法收敛于最优解或近似最优解。

在Ramaxel场景中，我们面临的是优化需求物料分配的问题，这可以被建模为一个寻找最优路径或序列的问题，非常适合应用蚁群优化算法。利用ACO，我们可以有效地探索解空间，通过信息素机制发现和增强通向高效需求满足策略的路径，同时保持对解空间探索的多样性，避免过早收敛于局部最优解。此外，ACO的自适应性使其能够很好地应对问题规模的变化和需求的动态性，为Ramaxel提供了一个强大的工具来优化其业务流程和资源利用。



### 7.2 信息素网络

#### 7.2.1 信息素网络的作用

在蚁群算法中，信息素是一种虚拟的化学物质，用来模拟蚂蚁在路径上留下的痕迹。蚁群算法中的每个蚂蚁都会根据信息素的分布来选择路径，同时也会在走过的路径上释放信息素，影响后续蚂蚁的路径选择。信息素的浓度代表了路径的优良程度，浓度越高意味着路径越可能是优解。

信息素的更新是蚁群算法中的核心机制之一，其主要目的和作用包括：

1. **增强优良路径的吸引力**：通过增加优良路径上的信息素浓度，使得该路径对后续蚂蚁更加吸引，从而增加被选择的概率。这有助于算法聚焦于高质量的解决方案。
2. **维持搜索的多样性**：信息素的蒸发机制减少了所有路径上的信息素浓度，防止算法过早地聚焦于局部最优解，保持了探索解空间的多样性。
3. **实现正反馈机制**：优良解的路径上信息素浓度的增加形成了正反馈，越多的蚂蚁选择某条路径，该路径上的信息素浓度越高，从而吸引更多的蚂蚁选择这条路径。
4. **动态调整搜索策略**：通过信息素的动态更新，蚁群算法能够根据已找到解的质量自动调整搜索策略，逐渐优化解决方案。

#### 7.2.2 信息素网络初始化

在蚁群算法中，信息素初始化是算法开始之前的重要步骤。均匀初始化是一种常见的初始化策略，其假设所有路径起初都是等价的，没有任何先验知识指示某些路径比其他路径更优。均匀初始化可以通过设置信息素网络中所有元素的初始值为一个常数来实现。这种初始化方式确保了在搜索开始时，蚂蚁不会因为信息素的差异而偏向于某些路径，从而保证了初始探索的公平性和多样性。

用一个$n×n$的二维矩阵表示信息素网络，其中行表示需求编号，列表示需求在整个序列中所处的位置编号，对应单元格的值表示信息素值，用$\tau_{i,j}$表示。

设定信息素网络的初始值为$\tau_0$，其中$\tau_0>0$。对于一个$n×n$的信息素网络，每个元素$\tau_{i,j}$的初始值可以表示为：
$$
\begin{align}
\tau_{i,j}(0)=\tau_0
\end{align}\tag{22}
$$
其中，$i$和$j$分别表示需求编号和需求在整个序列中的位置编号。

如下图所示，展示了3个不同需求分配序列对应信息素网络中的位置示例。

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202404161627924.png" style="zoom:50%;" />

#### 7.2.3  信息素值范围限制

为了防止信息素浓度过高或过低，影响算法的搜索能力和稳定性，通常会对信息素的值设定一个上限和下限。

设定信息素的上限为$\tau_{\max}$和下限为$\tau_{\min}$，则在信息素更新过程中，每次更新后的信息素浓度$\tau_{i,j}(t+1)$需要被限制在这个范围内：
$$
\begin{align}
\tau_{i,j}(t+1)=\min\left\{ \max\left[\tau_{i,j}(t+1),\tau_{\min}\right],\tau_{\max} \right\}
\end{align}\tag{22}
$$
这里，$t+1$表示更新后的迭代次数。

该公式确保了每次信息素更新后的值不会超出预设的范围，通过合理选择$\tau_{\max}$和$\tau_{\min}$的值，可以避免信息素浓度过快地收敛至极值，保持算法的探索能力和适应性。

### 7.3 启发函数

启发式函数（Heuristic Function）是一种用于指导搜索算法更快地找到问题解的方法。它基于问题特定的知识来评估解决方案的优劣，从而帮助算法做出决策。在优化和决策问题中，启发式函数的目的是提供一个快速但是近似的评价，指示特定的选择或路径如何接近最终目标。

#### 7.3.1 最大齐套量启发函数

当目标是最大化齐套量时，当目标是最大化齐套量时，启发式函数评估分配给特定需求的物料后能够实现的齐套量，齐套量直接反映了满足该需求后整体系统的效率或完成度。

因此，对于每个需求，其启发式函数值等于该需求分配完物料后的齐套量。高齐套比例意味着分配该物料后，能够满足更多的需求或更接近完成整个需求集合。
$$
\begin{align}
\eta_{i,j}^{k}(t)=F_{i,j}^{k}(t)
\end{align}\tag{22}
$$
其中，$\eta_{i,j}$为需求$D_i$在第$j$个位置时的启发函数，$k$为种群中的个体编号，$t$为当前迭代的次数，$F$为齐套数量函数。

#### 7.3.2 最小净需求启发函数

当目标是最小化净需求量（即最小化原材料缺料量）时，启发式函数的设计反映了每个决策对于减少整体缺料的贡献。

由于目标是最小化缺料，启发式函数需要与选择概率成正相关，同时希望值越大越好，因此可以采用缺料数量的倒数作为启发式函数值。这种设计鼓励选择那些导致整体缺料最小化的物料分配方案能够优先被选择。
$$
\begin{align}
\eta_{i,j}^{k}(t)=\frac{1}{F_{i,j}^{k}(t)+\epsilon}
\end{align}\tag{22}
$$
其中，$\eta_{i,j}$为需求$D_i$在第$j$个位置时的启发函数，$k$为种群中的个体编号，$t$为当前迭代的次数，$F$为净需求数量函数，$\epsilon$为一个较小的常数，为了防止分母为0。



### 7.4 轮盘赌选择策略

分别计算待分配需求池中每个需求的被选择概率，采用轮盘赌策略决策下一步分配的需求。

轮盘赌选择策略（Roulette Wheel Selection），也称为比例选择法，是一种用于启发式算法中的选择机制，特别是在遗传算法和蚁群算法等进化计算领域中广泛使用。该策略旨在模拟自然选择的过程，通过概率分布来选择个体，以便于算法能够在探索解空间和利用已知优解之间保持平衡。

1. **适应度计算**

   - 对于每个需求$D_i$，其信息素值为$\tau_{i,j}$，启发式函数值为$\eta_i$，需求$D_i$的适应值函数计算公式如下：

   $$
   \begin{align}
   \text{Fitness}_{i} = \big[\tau_{i,j}\big]^{\alpha}*\big[\eta_{i,j}\big]^{\beta}
   \end{align}\tag{22}
   $$

   

   - 计算所有需求的适应值总和

   $$
   \begin{align}
   T = \sum_{i}\text{Fitness}_i
   \end{align}\tag{22}
   $$

2. **概率分配**：将每个候选项的适应度转换为选择概率$P_{i}$，即将每个候选项的适应度除以所有候选项适应度的总和
   $$
   \begin{align}
   P_{i}=\frac{\text{Fitness}_{i}}{T}
   \end{align}\tag{22}
   $$

3. **累积概率**：计算每个候选项的累积概率$C_i$，即从第一个候选项到当前候选项的所有选择概率的总和，用于确定随机选择的需求
   $$
   \begin{align}
   C_{i}=\sum_{i'=1}^{i}P_{i'}
   \end{align}\tag{22}
   $$

4. **选择过程**：

   - 生成一个介于0和1之间的随机数；
   - 根据生成的随机数，选择第一个累积概率大于随机数的需求；
   - 这样，适应度高的需求被选择的概率更大，但适应度较低的需求仍有机会被选择，保留了种群的多样性。



### 7.5 更新信息素网络

信息素更新通常在所有蚂蚁完成一次迭代（即一次完整的解构建过程）后进行，包括两个信息素挥发和信息素强化两个过程。

#### 7.5.1 信息素挥发

在蚁群优化算法中，信息素挥发是通过在每次迭代后对信息素浓度进行递减来实现的。这一机制模拟了自然界中蚂蚁留下的信息素随时间逐渐挥发的现象。信息素挥发对算法的搜索策略有重要影响，旨在防止算法仅探索初始阶段发现的优良路径，从而忽略其他可能的优解。

设定信息素挥发率为 $\rho$（其中$0 < \rho < 1$ ），对于信息素网络中的每个信息素浓度值$\tau_{i,j}$，信息素挥发后的更新公式为：
$$
\begin{align}
\tau_{i,j}(t+1)=(1-\rho)*\tau_{i,j}(t)
\end{align}\tag{22}
$$
其中，$\tau_{i,j}(t)$表示在当前迭代轮数$t$的信息素浓度值，$(1-\rho)$是信息素保留的比例，$\rho$是信息素挥发的比例，$\tau_{i,j}(t+1)$表示挥发后用于下一轮迭代中计算使用的信息素浓度值。

#### 7.5.2 信息素强化

信息素强化是蚁群算法中的一个关键环节，旨在根据蚂蚁找到的优良路径来增加相应路径的信息素浓度，从而引导后续蚂蚁的搜索方向。

特别地，结合使用迭代最优解（Iteration Best Solution，IBS）和全局最优解（Global Best Solution，GBS），并结合周期性增强机制，以实现更有效的搜索优化。

进行信息素强化是一种有效的策略，能够有效地在探索（Exploration）和利用（Exploitation）之间达到平衡。这种策略既利用了算法的全局搜索能力，又保持了对当前最有希望区域的关注，有助于在提高收敛速度的同时，也增强了找到更好解决方案的概率。

- **探索（Exploration）**：通过考虑IBS进行信息素更新，算法能够灵活地响应最近的搜索经验，探索可能的新区域。
- **利用（Exploitation）**：通过考虑GBS进行信息素更新，算法保持对已知最佳解决方案的关注，避免远离最优路径。



##### 7.5.2.1 基于迭代最优解的强化

在每次迭代中，无论是否发现新的全局最优解，都会根据当前迭代最优解（IBS）来增加信息素。



##### 7.5.2.2 基于全局最优解的强化

- 当出现新的全局最优解（GBS）时，除了基于迭代最优解的信息素增量外，还会根据全局最优解来进一步增加信息素。
- 在达到设定的周期（无新的全局最优解出现），即使没有新的全局最优解被发现，也会按照全局最优解的增量进行周期性增加。



##### 7.5.2.3 周期性强化

- 设定周期长度，如每20次迭代进行一次基于全局最优解的额外强化。
- 该机制确保算法即使在一段时间内未能发现新的全局最优解，也能保持对当前已知最优解的强化，从而避免解的多样性降低或过早收敛。



#### 7.5.3 信息素更新

信息素增量在蚁群算法中起到了至关重要的作用，它模拟了自然界中蚂蚁通过留下信息素来标记“优良路径”的行为。在算法中，信息素增量反映了某条路径被认为是通往优解的“优良性”：

- **$\Delta^{(1)}\tau_{i,j}$（基于迭代最优解的增量）**：这代表了在当前迭代中找到的最优解对应路径的优良性。当某路径因为当前迭代中的某个蚂蚁而被选中，并指向了一个优质解时，这条路径上的信息素浓度会增加，意味着这条路径被认为更可能通向优解。这种机制鼓励后续的蚂蚁倾向于探索这些已被验证为优良的路径，从而促进算法快速收敛。
- **$\Delta^{(2)}\tau_{i,j}$（基于全局最优解的增量）**：这反映了到目前为止算法找到的全局最优解对应路径的优良性。不仅在新的全局最优解被发现时增加信息素，而且在特定周期内即使没有新的全局最优解出现也会增加，保持了对全局最优解的持续关注。这有助于维持算法对已知最佳路径的记忆，同时避免因短期内的探索波动而忽视这些已验证的优良路径。



**（1）最大化齐套数量信息素增量**

在MPS/短期齐套场景中，目标是最大化需求齐套数量。这意味着在物料供给数量有限情况下，尽可能满足最多需求的齐套数量。

假设某次迭代中找到的最优解的齐套数量为$F_{IBS}$，则IBS的信息素增量$\Delta^{(1)}\tau_{i,j}$直接与$F_{IBS}$成正比
$$
\begin{align}
\Delta^{(1)}\tau_{i,j}(t)=\xi_1*F_{IBS}
\end{align}\tag{22}
$$
其中，$\xi_1>0$，常数，用于调整信息素增量的大小。

通过这种方式，能够直接增加与齐套数量大的解相关联的路径上的信息素浓度，鼓励算法在后续迭代中选择能够满足更多需求的解。



对于到目前为止找到的齐套数量最大的全局最优解$F_{GBS}$，全局最优解的信息素增量$\Delta^{(2)}\tau_{i,j}$也与$F_{GBS}$成正比：
$$
\begin{align}
\Delta^{(2)}\tau_{i,j}(t)=\xi_1*F_{GBS}
\end{align}\tag{22}
$$
这种方法确保了全局最优解能够对信息素网络产生持续的正面影响，引导蚂蚁群集中探索能够最大化齐套数量的路径或决策。



**（2）最小化净需求量信息素增量**

在SNP/MRP/资金计划场景中，目标是最小化物料的净需求量。这意味着在满足需求量的同时，希望减少所需原材料数量超过现有库存量的情况，即最小化缺料量。

假设某次迭代中找到的最优解的净需求数量为$F_{IBS}$，则IBS的信息素增量$\Delta^{(1)}\tau_{i,j}$直接与$F_{IBS}$成反比
$$
\begin{align}
\Delta^{(1)}\tau_{i,j}(t)=\xi_2*\frac{1}{F_{IBS}+\epsilon}
\end{align}\tag{22}
$$
其中，$\xi_2>0$，常数，用于调整信息素增量的大小。$\epsilon>0$是一个很小的正数，用以避免除以零的情况。

这种方式意在通过与净需求数量的倒数成比例来增加信息素浓度，鼓励算法倾向于选择缺料量更少的解。



对于到目前为止找到的净需求数量最小的全局最优解$F_{GBS}$，全局最优解的信息素增量$\Delta^{(2)}\tau_{i,j}$也可以采用类似的方式：
$$
\begin{align}
\Delta^{(2)}\tau_{i,j}(t)=\xi_2*\frac{1}{F_{GBS}+\epsilon}
\end{align}\tag{22}
$$
这样，全局最优解的信息素增量也与其净需求数量的倒数成正比，进一步强化了信息素网络中指向更优解的路径，引导蚂蚁群集中探索可能减少净需求量的解。



综上所述，结合上述信息素挥发机制和强化机制，对于最大化和最小化场景，每次迭代完成后信息素的更新公式都可以表达为：

当未发现全局最优解时：
$$
\begin{align}
\tau_{i,j}(t+1)=(1-\rho)*\tau_{i,j}(t)+\Delta^{(1)}\tau_{i,j}(t)
\end{align}\tag{22}
$$
当发现新的全局最优解或达到周期性强化时：
$$
\begin{align}
\tau_{i,j}(t+1)=(1-\rho)*\tau_{i,j}(t)+\Delta^{(1)}\tau_{i,j}(t)+\Delta^{(2)}\tau_{i,j}(t)
\end{align}\tag{22}
$$



### 7.6 混合更新策略

为了应对大规模的优化问题，并在保证算法探索全局最优解的同时提高计算效率，本算法采用混合更新策略。该策略结合了周期性全量更新和局部搜索策略，利用轮盘赌选择策略（见7.5节）和信息素网络更新机制（见7.6节）来实现更加动态和灵活的搜索过程。

#### 7.6.1 周期性全量更新策略

##### 7.6.1.1 策略概述

全量更新是指在预定的周期（如每N次迭代）全面重新构造需求序列，并基于这些新构造的序列更新信息素。这种方法能够确保算法定期“重置”，从而避免陷入局部最优解并保持对解空间的全面探索。

##### 7.6.1.2 实施细节

- **周期设置**

  设定全量更新周期N，例如每N次迭代执行一次全量更新。选择合适的N值对算法的探索-利用平衡至关重要。

- **序列重构**

  在全量更新阶段，每只蚂蚁将重新评估并构造整个需求序列。这一过程遵循式(22)，依据当前信息素$\tau_{i,j}$和启发式信息$\eta_{i,j}$，通过7.5节轮盘赌选择策略进行需求选择。

- **信息素更新**

  根据重构后的需求序列及其评估结果，采用7.6节描述的信息素更新公式对信息素进行相应的调整，以反映新解的质量和偏好。

##### 7.6.1.3 预期效果

这一策略能够定期重置搜索过程，帮助算法跳出局部最优解，确保长期运行时的探索全面性和解的多样性。

#### 7.6.2 局部搜索策略

##### 7.6.2.1 策略概述

在非全量更新的迭代中，算法将选择需求序列中的一小部分进行局部优化。该策略旨在通过集中优化这些局部区域，快速改善解的质量，同时减少计算成本。

##### 7.6.2.2 实施细节

- **选择更新区域**

  每次局部搜索前，随机选取连续的一段需求作为更新区域（如某一「时间优先级」相同的需求，或某一「时间优先级 + 原始优先级」相同的需求）。

- **局部序列重构**

  在选定的更新区域内，利用7.5节轮盘赌选择策略重新构造需求序列。这一过程依然基于当前的信息素浓度$\tau_{i,j}$和启发式信息$\eta_{i,j}$。这类似于全量更新过程，但仅限于局部。

- **信息素更新**

  根据局部优化的结果，更新相关路径上的信息素。具体更新策略依照7.6节中描述的信息素更新方法。

##### 7.6.2.3 预期效果

局部搜索能够在不影响全局搜索质量的前提下，显著提高计算效率。它使算法能够更快地聚焦于解的某一部分，加速搜索过程。

#### 7.6.3 混合策略的实施和调整

混合更新策略的关键在于根据算法的当前表现和问题规模动态调整全量更新和局部搜索的频率及范围。例如，可以通过逐步减小全量更新的频率N和逐步增加局部搜索范围的大小来适应算法的收敛过程。

**调整策略**：

- 在算法早期或探索进展缓慢时增加全量更新的频率，以确保解的多样性和全面性。
- 随着算法的收敛，减少全量更新的频率，增加局部搜索的使用，特别是针对那些信息素变化显著的区域。
- 动态调整参数（如信息素挥发率$\rho$），以适应算法的搜索状态和优化目标的特性。

通过上述混合更新策略的实施，Ramaxel的蚁群优化算法能够有效地平衡全局搜索与局部优化，从而在大规模和动态变化的问题场景中找到优质的需求物料分配方案。



## 8. GA for Ramaxel

### 8.1 初始解

#### 8.1.1 需求序列构造

时间优先级 + 原始优先级 + 物料编码

#### 8.1.2 分配流程

- 需求序列构造（时间优先级+原始优先级）
- 分配流程（同一时间优先级，先分配本工厂再跨工厂）
- 复杂BOM处理（求解器+搜索）

### 8.2 选择算子(Selection Operator)

#### 8.2.1 轮盘赌选择(Roulette Wheel Selection)

#### 8.2.2 精英选择(Elitism Selection)

### 8.3 交叉算子(Crossover Operator)

交叉算子定义了如何从父代个体中生成子代。

在本问题中，由于同一时间优先级+原始优先级分组内的需求允许交换顺序，跨组不允许交换。

#### 8.3.1 顺序交叉(Order Crossover, OX)

#### 8.3.2 部分映射交叉(Partially Mapped Crossover, PMX)

这种方法适用于排列编码，能保持父代的相对顺序和位置信息。

当选择两个交叉点时，只在同一时间优先级+原始优先级的分组内选择交叉点，以保证跨组需求不被交换。

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403211641902.png" style="zoom:50%;" />

### 8.4 变异算子(Mutation Operator)

#### 8.4.1 交换变异(Swap Mutation)

#### 8.4.2 逆转变异(Inversion Mutation)

## 9. 代码架构

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403211628768.png" style="zoom:50%;" />

## 10. 待确认问题

- 最小化净需求计算时，是直接按占料分配，还是先计算让料（齐套）再基于让料结果分配剩余的物料；
  - 直接按占料分配

- 现在的业务需求，如匹配库位，加客户，产线等，都比较业务化，不能很好地从一个客户场景移植到另一个客户场景，复用程度不高。为了提高后续复用程度，如何抽象化业务含义的处理；
  - A in B or B为空 的情况抽成stock_loc_relation_list，其中A是需求，B是供给

- 复杂BOM判断是在java判断还是算法判断；
  - java判断后传入复杂BOM标识

- MPS是否接SNP计算结果，对结果整体影响不大，如果接则需要在MPS计算时将下层齐套量更新到上层的可用供给中，这一部分为新增；
  - MPS不接SNP的结算结果

- 本次计算是否跨工厂，从输入数据控制还是算法分配流程中控制；
  - 输入数据控制

- MPS模拟运算，需要快速出结果，迭代次数设置成1；

- 线程数与种群规模关系；
  - 没有关系，单独设置；
- 是更看重解的质量还是计算时间；
  - 
- 多租户同时运行任务的问题；
  - 每个租户用独立的线程池，通过配置文件设置线程数量；

<img src="https://gitee.com/uc4334/imgs/raw/master/img/202403211422401.png" style="zoom:50%;" />



- 如何定义供给数据的结构

  - WHP的分配流程
    - 计算最大齐套量作为启发函数；
    - 根据启发函数信息更新信息素网络，利用随机选择过程选择一个需求进行处理；
    - 对所选需求进行详细计算，包括分配明细和目标函数；
    - 根据需求计算结果扣减更新库存信息；
    - 从待分配需求池中移除已分配的需求；
    - 将已分配需求目标值信息添加到需求目标信息池中；
  - WHP根据day分类了，无需考虑时间约束，可以先计算最大齐套量；




2024-03-29

- 构建BOM的两种方式：

  6w订单数据，600w笔BOM数据

  - 计算前处理构建完整BOM：内存开销大；
  - 一边计算一边构建BOM：耗时（WHP采用的方式）；


2024-04-10

- 不同租户之间是否数据完全隔离；完全隔离

  - 通过配置文件预先设定不同租户的线程数，不支持在服务运行中动态增加租户数量。
  - 如果后续需要增加租户，则通过更改配置文件再重启服务。

- 分配结果如何验证满足约束条件（目前9条匹配条件）；

  - 输出结果中带出约束条件，人工校验；

- 与业务方讲解算法到什么颗粒度，流程&逻辑&优化算法；

  - 

- 最小化净需求模型中，目标函数是否会发生改变；

  - 就记忆科技项目来说，单目标优化不会改变；

  

